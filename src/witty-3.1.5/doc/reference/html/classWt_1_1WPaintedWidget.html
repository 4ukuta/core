<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Wt: Wt::WPaintedWidget Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceWt.html">Wt</a>::<a class="el" href="classWt_1_1WPaintedWidget.html">WPaintedWidget</a>
  </div>
</div>
<div class="contents">
<h1>Wt::WPaintedWidget Class Reference<br>
<small>
[<a class="el" href="group__painting.html">Painting system</a>]</small>
</h1><!-- doxytag: class="Wt::WPaintedWidget" --><!-- doxytag: inherits="Wt::WInteractWidget" -->A widget that is painted using vector graphics.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Wt/WPaintedWidget&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Wt::WPaintedWidget:</div>
<div class="dynsection">
<p><center><img src="classWt_1_1WPaintedWidget__inherit__graph.png" border="0" usemap="#Wt_1_1WPaintedWidget__inherit__map" alt="Inheritance graph"></center>
<map name="Wt_1_1WPaintedWidget__inherit__map">
<area shape="rect" href="classWt_1_1Chart_1_1WAbstractChart.html" title="Abstract base class for MVC&#45;based charts." alt="" coords="101,379,277,405"><area shape="rect" href="classWt_1_1WInteractWidget.html" title="An abstract widget that can receive user&#45;interface interaction." alt="" coords="119,229,260,256"><area shape="rect" href="classWt_1_1WWebWidget.html" title="A base class for widgets with an HTML counterpart." alt="" coords="128,155,251,181"><area shape="rect" href="classWt_1_1WWidget.html" title="The abstract base class for a user&#45;interface component." alt="" coords="141,80,237,107"><area shape="rect" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system." alt="" coords="141,5,237,32"><area shape="rect" href="classWt_1_1Chart_1_1WCartesianChart.html" title="A cartesian chart." alt="" coords="5,453,187,480"><area shape="rect" href="classWt_1_1Chart_1_1WPieChart.html" title="A pie chart." alt="" coords="211,453,357,480"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classWt_1_1WPaintedWidget-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923">Method</a> { <a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923eea4494d5f2a458fbdacea02d1e009a3">InlineSvgVml</a>, 
<a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923ce6fa43830fac95b0f042cd1438e41df">HtmlCanvas</a>, 
<a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c692321638ccefa8f41adf2fde2986a8e02ec">PngImage</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration that indicates a rendering method.  <a href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fdb2dbe95de7b97d77a1778724395db6"></a><!-- doxytag: member="Wt::WPaintedWidget::WPaintedWidget" ref="fdb2dbe95de7b97d77a1778724395db6" args="(WContainerWidget *parent=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#fdb2dbe95de7b97d77a1778724395db6">WPaintedWidget</a> (<a class="el" href="classWt_1_1WContainerWidget.html">WContainerWidget</a> *parent=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new painted widget. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3e28c52034a50cb9c2c2e7a9e979a90c"></a><!-- doxytag: member="Wt::WPaintedWidget::~WPaintedWidget" ref="3e28c52034a50cb9c2c2e7a9e979a90c" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#3e28c52034a50cb9c2c2e7a9e979a90c">~WPaintedWidget</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#2a3a3be8b9a8c6d56fad4b64b370fdd4">setPreferredMethod</a> (<a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923">Method</a> method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the preferred rendering method.  <a href="#2a3a3be8b9a8c6d56fad4b64b370fdd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923">Method</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#701e81be3104d98a02f4cf7da9ec3a7f">preferredMethod</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the preferred rendering method.  <a href="#701e81be3104d98a02f4cf7da9ec3a7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#3d4b42ac400fb9ba56c6b02aa4615775">update</a> (WFlags&lt; <a class="el" href="namespaceWt.html#23a1002020ee93ed4679d351b7350de3">PaintFlag</a> &gt; flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lets the widget repaint itself.  <a href="#3d4b42ac400fb9ba56c6b02aa4615775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#a57b940110d240951d0e3a6d03390319">resize</a> (const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;width, const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes the widget.  <a href="#a57b940110d240951d0e3a6d03390319"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#c4c031c7ab47e85f27aac09b7fc37bea">addArea</a> (<a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> *area)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an interactive area.  <a href="#c4c031c7ab47e85f27aac09b7fc37bea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#f11281366adb6c4d7966b3b19651ea0f">insertArea</a> (int index, <a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> *area)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts an interactive area.  <a href="#f11281366adb6c4d7966b3b19651ea0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#0147ad94c849d437be8bfde14df579a5">removeArea</a> (<a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> *area)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an interactive area.  <a href="#0147ad94c849d437be8bfde14df579a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#38786c86ffb7c62ee13b18f0874cb262">area</a> (int index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the interactive area at the given index.  <a href="#38786c86ffb7c62ee13b18f0874cb262"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector<br>
&lt; <a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#e3cfb09afc47aa57c1ca9fda0e3cbb5e">areas</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the interactive areas set for this widget.  <a href="#e3cfb09afc47aa57c1ca9fda0e3cbb5e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#0c4a7fd06c6e3092283dedc02214f64e">layoutSizeChanged</a> (int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual method that indicates a size change.  <a href="#0c4a7fd06c6e3092283dedc02214f64e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#d8ce22eff41754c8616f45851f57fb1a">paintEvent</a> (<a class="el" href="classWt_1_1WPaintDevice.html">WPaintDevice</a> *paintDevice)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Paints the widget.  <a href="#d8ce22eff41754c8616f45851f57fb1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WPaintedWidget.html#15c48f15b7b920ab2577caade798a2fd">enableAjax</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Progresses to an Ajax-enabled widget.  <a href="#15c48f15b7b920ab2577caade798a2fd"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A widget that is painted using vector graphics. 
<p>
A painted widget is rendered from basic drawing primitives. Rendering is done not on the server but on the browser, using different rendering methods:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Browser</b></td><td><b>Methods</b> </td><td><b>Default method</b> </td></tr>
<tr>
<td>Firefox 1.5+</td><td>HtmlCanvas, InlineSVG, PngImage </td><td>HtmlCanvas </td></tr>
<tr>
<td>Internet Explorer 6.0+</td><td>InlineVML, PngImage </td><td>InlineVML </td></tr>
<tr>
<td>Safari</td><td>HtmlCanvas, InlineSVG, PngImage </td><td>HtmlCanvas </td></tr>
<tr>
<td>Opera</td><td>InlineSVG, HtmlCanvas*, PngImage </td><td>InlineSVG </td></tr>
<tr>
<td>other</td><td>?</td><td>HtmlCanvas, PngImage </td></tr>
</table>
<p>
<em>* HtmlCanvas occasionally suffers from rendering artefacts in Opera.</em><p>
The different rendering methods correspond to different <a class="el" href="classWt_1_1WPaintDevice.html" title="The abstract base class for a paint device.">WPaintDevice</a> implementations, from which this widget choses a suitable one depending on the browser capabilities and configuration.<p>
If no JavaScript is available, the JavaScript-based HtmlCanvas will not be used, and InlineSVG will be used instead. The method used may be changed by using <a class="el" href="classWt_1_1WPaintedWidget.html#2a3a3be8b9a8c6d56fad4b64b370fdd4" title="Sets the preferred rendering method.">setPreferredMethod()</a>.<p>
InlineSVG requires that the document is rendered as XHTML. This must be enabled in the configuration file using the <code>&lt;send-xhtml-mime-type&gt;</code> option. By default, this option is off.<p>
The PngImage is the most portable rendering method, and may be the fastest if the painting is of high complexity and/or the image is fairly small.<p>
To use a WPaintedWidget, you must derive from it and reimplement <a class="el" href="classWt_1_1WPaintedWidget.html#d8ce22eff41754c8616f45851f57fb1a" title="Paints the widget.">paintEvent(WPaintDevice *paintDevice)</a>. To paint on a <a class="el" href="classWt_1_1WPaintDevice.html" title="The abstract base class for a paint device.">WPaintDevice</a>, you will need to use a <a class="el" href="classWt_1_1WPainter.html" title="Vector graphics painting class.">WPainter</a>. Repainting is triggered by calling the <a class="el" href="classWt_1_1WPaintedWidget.html#3d4b42ac400fb9ba56c6b02aa4615775" title="Lets the widget repaint itself.">update()</a> method.<p>
Usage example: <div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyPaintedWidget : <span class="keyword">public</span> Wt::<a class="code" href="classWt_1_1WPaintedWidget.html#fdb2dbe95de7b97d77a1778724395db6" title="Create a new painted widget.">WPaintedWidget</a>
 {
 <span class="keyword">public</span>:
   MyPaintedWidget(<a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *parent = 0)
     : Wt::<a class="code" href="classWt_1_1WPaintedWidget.html#fdb2dbe95de7b97d77a1778724395db6" title="Create a new painted widget.">WPaintedWidget</a>(parent),
       foo_(100)
   {
      <a class="code" href="classWt_1_1WPaintedWidget.html#a57b940110d240951d0e3a6d03390319" title="Resizes the widget.">resize</a>(200, 200); <span class="comment">// provide a default size</span>
   }

   <span class="keywordtype">void</span> setFoo(<span class="keywordtype">int</span> foo) {
      foo_ = foo;
      <a class="code" href="classWt_1_1WPaintedWidget.html#3d4b42ac400fb9ba56c6b02aa4615775" title="Lets the widget repaint itself.">update</a>(); <span class="comment">// trigger a repaint</span>
   }

 <span class="keyword">protected</span>:
   <span class="keywordtype">void</span> <a class="code" href="classWt_1_1WPaintedWidget.html#d8ce22eff41754c8616f45851f57fb1a" title="Paints the widget.">paintEvent</a>(<a class="code" href="classWt_1_1WPaintDevice.html" title="The abstract base class for a paint device.">Wt::WPaintDevice</a> *paintDevice) {
     <a class="code" href="classWt_1_1WPainter.html" title="Vector graphics painting class.">Wt::WPainter</a> painter(paintDevice);
     painter.drawLine(20, 20, foo_, foo_);
     ...
   }

 <span class="keyword">private</span>:
   <span class="keywordtype">int</span> foo_;
 };
</pre></div><p>
<h3>CSS</h3>
<p>
Styling through CSS is not applicable.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A WPaintedWidget requires that it is given a size using <a class="el" href="classWt_1_1WPaintedWidget.html#a57b940110d240951d0e3a6d03390319" title="Resizes the widget.">resize()</a> or by a layout manager.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WImage.html" title="A widget that displays an image.">WImage</a> </dd></dl>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="fa5ee04c391e6ac67d58740fc80c6923"></a><!-- doxytag: member="Wt::WPaintedWidget::Method" ref="fa5ee04c391e6ac67d58740fc80c6923" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923">Wt::WPaintedWidget::Method</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration that indicates a rendering method. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="fa5ee04c391e6ac67d58740fc80c6923eea4494d5f2a458fbdacea02d1e009a3"></a><!-- doxytag: member="InlineSvgVml" ref="fa5ee04c391e6ac67d58740fc80c6923eea4494d5f2a458fbdacea02d1e009a3" args="" -->InlineSvgVml</em>&nbsp;</td><td>
SVG (Most browsers) or VML (Internet Explorer) embedded in the page. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fa5ee04c391e6ac67d58740fc80c6923ce6fa43830fac95b0f042cd1438e41df"></a><!-- doxytag: member="HtmlCanvas" ref="fa5ee04c391e6ac67d58740fc80c6923ce6fa43830fac95b0f042cd1438e41df" args="" -->HtmlCanvas</em>&nbsp;</td><td>
The WHATWG HTML 5 canvas element. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fa5ee04c391e6ac67d58740fc80c692321638ccefa8f41adf2fde2986a8e02ec"></a><!-- doxytag: member="PngImage" ref="fa5ee04c391e6ac67d58740fc80c692321638ccefa8f41adf2fde2986a8e02ec" args="" -->PngImage</em>&nbsp;</td><td>
Using a PNG image resource. </td></tr>
</table>
</dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WObject.html#6ef714d6ef0060b78c039e729b913aa9">Wt::WObject</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2a3a3be8b9a8c6d56fad4b64b370fdd4"></a><!-- doxytag: member="Wt::WPaintedWidget::setPreferredMethod" ref="2a3a3be8b9a8c6d56fad4b64b370fdd4" args="(Method method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::setPreferredMethod           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923">Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the preferred rendering method. 
<p>
When <code>method</code> is supported by the browser, then it is chosen for rendering. 
</div>
</div><p>
<a class="anchor" name="701e81be3104d98a02f4cf7da9ec3a7f"></a><!-- doxytag: member="Wt::WPaintedWidget::preferredMethod" ref="701e81be3104d98a02f4cf7da9ec3a7f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WPaintedWidget.html#fa5ee04c391e6ac67d58740fc80c6923">Method</a> Wt::WPaintedWidget::preferredMethod           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the preferred rendering method. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WPaintedWidget.html#2a3a3be8b9a8c6d56fad4b64b370fdd4" title="Sets the preferred rendering method.">setPreferredMethod(Method)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d4b42ac400fb9ba56c6b02aa4615775"></a><!-- doxytag: member="Wt::WPaintedWidget::update" ref="3d4b42ac400fb9ba56c6b02aa4615775" args="(WFlags&lt; PaintFlag &gt; flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::update           </td>
          <td>(</td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#23a1002020ee93ed4679d351b7350de3">PaintFlag</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lets the widget repaint itself. 
<p>
Repainting is not immediate, but happens after when the event loop is exited. 
</div>
</div><p>
<a class="anchor" name="a57b940110d240951d0e3a6d03390319"></a><!-- doxytag: member="Wt::WPaintedWidget::resize" ref="a57b940110d240951d0e3a6d03390319" args="(const WLength &amp;width, const WLength &amp;height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::resize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes the widget. 
<p>
Specify a new size for this widget, by specifying width and height. By default a widget has automatic width and height, see <a class="el" href="classWt_1_1WLength.html#b4c9733029342fdbc1dee34a523ee40d" title="Returns whether the ength is &#39;auto&#39;.">WLength::isAuto()</a>.<p>
This applies to CSS-based layout, and only <a class="el" href="classWt_1_1WWebWidget.html#73c0244d363cd2f8bd4814fe1ebee2b1">block</a> widgets can be given a size reliably.<p>
When inserted in a layout manager, the widget may be informed about its current size using <a class="el" href="classWt_1_1WWidget.html#4f83592912a7f8fa4fd35dadde78ee74" title="Sets the widget to be aware of its size set by a layout manager.">setLayoutSizeAware()</a>. If you have defined a "wtResize()" JavaScript method for the widget, then this method will also be called. operation.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WWebWidget.html#4187ef41415521e545106c970c2679f2" title="Returns the width.">width()</a>, <a class="el" href="classWt_1_1WWebWidget.html#7321103dca90574bbc3ac6ea9a91ccff" title="Returns the height.">height()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WWebWidget.html#e1b84e31581405358b6d57ec14505234">Wt::WWebWidget</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4c031c7ab47e85f27aac09b7fc37bea"></a><!-- doxytag: member="Wt::WPaintedWidget::addArea" ref="c4c031c7ab47e85f27aac09b7fc37bea" args="(WAbstractArea *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::addArea           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> *&nbsp;</td>
          <td class="paramname"> <em>area</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an interactive area. 
<p>
Adds the <code>area</code> which listens to events in a specific region of the widget. Areas are organized in a list, to which the given <code>area</code> is appended. When areas overlap, the area with the lowest index receives the event.<p>
Ownership of the <code>area</code> is transferred to the widget.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When defining at least one area, no more events will propagate to the widget itself. As a work-around, you can emulate this by listening for events on a <a class="el" href="classWt_1_1WRectArea.html" title="A interactive area in a widget, specified by a rectangle.">WRectArea</a> that corresponds to the whole widget, and which is added as the last area (catching all events that were not caught by preceding areas).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WPaintedWidget.html#f11281366adb6c4d7966b3b19651ea0f" title="Inserts an interactive area.">insertArea(int, WAbstractArea *)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f11281366adb6c4d7966b3b19651ea0f"></a><!-- doxytag: member="Wt::WPaintedWidget::insertArea" ref="f11281366adb6c4d7966b3b19651ea0f" args="(int index, WAbstractArea *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::insertArea           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> *&nbsp;</td>
          <td class="paramname"> <em>area</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts an interactive area. 
<p>
Inserts the <code>area</code> which listens to events in the coresponding area of the widget. Areas are organized in a list, and the <em>area</em> is inserted at index <code>index</code>. When areas overlap, the area with the lowest index receives the event.<p>
Ownership of the <code>Area</code> is transferred to the widget.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When defining at least one area, no more events will propagate to the widget itself. As a work-around, you can emulate this by listening for events on a <a class="el" href="classWt_1_1WRectArea.html" title="A interactive area in a widget, specified by a rectangle.">WRectArea</a> that corresponds to the whole widget, and which is added as the last area (catching all events that were not caught by preceding areas).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WPaintedWidget.html#c4c031c7ab47e85f27aac09b7fc37bea" title="Adds an interactive area.">addArea(WAbstractArea *)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0147ad94c849d437be8bfde14df579a5"></a><!-- doxytag: member="Wt::WPaintedWidget::removeArea" ref="0147ad94c849d437be8bfde14df579a5" args="(WAbstractArea *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::removeArea           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> *&nbsp;</td>
          <td class="paramname"> <em>area</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an interactive area. 
<p>
Removes the <code>area</code> from this widget, returning the ownership.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WPaintedWidget.html#c4c031c7ab47e85f27aac09b7fc37bea" title="Adds an interactive area.">addArea(WAbstractArea *)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="38786c86ffb7c62ee13b18f0874cb262"></a><!-- doxytag: member="Wt::WPaintedWidget::area" ref="38786c86ffb7c62ee13b18f0874cb262" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> * Wt::WPaintedWidget::area           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the interactive area at the given index. 
<p>
Returns <code>0</code> if <code>index</code> was invalid.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WPaintedWidget.html#f11281366adb6c4d7966b3b19651ea0f" title="Inserts an interactive area.">insertArea(int, WAbstractArea *)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3cfb09afc47aa57c1ca9fda0e3cbb5e"></a><!-- doxytag: member="Wt::WPaintedWidget::areas" ref="e3cfb09afc47aa57c1ca9fda0e3cbb5e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classWt_1_1WAbstractArea.html">WAbstractArea</a> * &gt; Wt::WPaintedWidget::areas           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the interactive areas set for this widget. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WPaintedWidget.html#c4c031c7ab47e85f27aac09b7fc37bea" title="Adds an interactive area.">addArea()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0c4a7fd06c6e3092283dedc02214f64e"></a><!-- doxytag: member="Wt::WPaintedWidget::layoutSizeChanged" ref="0c4a7fd06c6e3092283dedc02214f64e" args="(int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::layoutSizeChanged           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual method that indicates a size change. 
<p>
This method propagates the client-side width and height of the widget when the widget is contained by a layout manager and setLayoutSizeAware(true) was called.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WWidget.html#4f83592912a7f8fa4fd35dadde78ee74" title="Sets the widget to be aware of its size set by a layout manager.">setLayoutSizeAware()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WWidget.html#f432588db3d599f89b54121f2ede8d63">Wt::WWidget</a>.</p>

</div>
</div><p>
<a class="anchor" name="d8ce22eff41754c8616f45851f57fb1a"></a><!-- doxytag: member="Wt::WPaintedWidget::paintEvent" ref="d8ce22eff41754c8616f45851f57fb1a" args="(WPaintDevice *paintDevice)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wt::WPaintedWidget::paintEvent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WPaintDevice.html">WPaintDevice</a> *&nbsp;</td>
          <td class="paramname"> <em>paintDevice</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Paints the widget. 
<p>
You should reimplement this method to paint the contents of the widget, using the given paintDevice. 
<p>Implemented in <a class="el" href="classWt_1_1Chart_1_1WCartesianChart.html#3c9c7e5fd246fd0d3e0efa0cd29dd997">Wt::Chart::WCartesianChart</a>, and <a class="el" href="classWt_1_1Chart_1_1WPieChart.html#b1653eea26f873b295a7350bd0dbb9ac">Wt::Chart::WPieChart</a>.</p>

</div>
</div><p>
<a class="anchor" name="15c48f15b7b920ab2577caade798a2fd"></a><!-- doxytag: member="Wt::WPaintedWidget::enableAjax" ref="15c48f15b7b920ab2577caade798a2fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WPaintedWidget::enableAjax           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Progresses to an Ajax-enabled widget. 
<p>
This method is called when the progressive bootstrap method is used, and support for AJAX has been detected. The default behavior will upgrade the widget's event handling to use AJAX instead of full page reloads, and propagate the call to its children.<p>
You may want to reimplement this method if you want to make changes to widget when AJAX is enabled. You should always call the base implementation.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WApplication.html#78016406c4746c56b2c2ffce7c5e181f" title="Progresses to an Ajax-enabled user interface.">WApplication::enableAjax()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WWebWidget.html#2893433f4aa1d6775875f1ebddd7c5ba">Wt::WWebWidget</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Fri Sep 10 16:33:02 2010 for <a href="http://www.webtoolkit.eu/wt/">Wt</a> by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
