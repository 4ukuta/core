<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Wt: Wt::WResource Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceWt.html">Wt</a>::<a class="el" href="classWt_1_1WResource.html">WResource</a>
  </div>
</div>
<div class="contents">
<h1>Wt::WResource Class Reference</h1><!-- doxytag: class="Wt::WResource" --><!-- doxytag: inherits="Wt::WObject" -->An object which can be rendered in the HTTP protocol.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Wt/WResource&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Wt::WResource:</div>
<div class="dynsection">
<p><center><img src="classWt_1_1WResource__inherit__graph.png" border="0" usemap="#Wt_1_1WResource__inherit__map" alt="Inheritance graph"></center>
<map name="Wt_1_1WResource__inherit__map">
<area shape="rect" href="classWt_1_1Ext_1_1DataStore.html" title="A resource that serializes data from a data model." alt="" coords="324,5,455,35"><area shape="rect" href="classWt_1_1WFileResource.html" title="A resource which streams data from a local file." alt="" coords="323,59,456,88"><area shape="rect" href="classWt_1_1WMemoryResource.html" title="A resource which streams data from memory." alt="" coords="309,112,469,141"><area shape="rect" href="classWt_1_1WPdfImage.html" title="A paint device for rendering to a PDF." alt="" coords="333,165,445,195"><area shape="rect" href="classWt_1_1WRasterImage.html" title="A paint device for rendering to a raster image." alt="" coords="324,219,455,248"><area shape="rect" href="classWt_1_1WSvgImage.html" title="A paint device for rendering using Scalable Vector Graphics (SVG)." alt="" coords="332,272,447,301"><area shape="rect" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system." alt="" coords="7,139,100,168"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classWt_1_1WResource-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b4a2f71811a597a3603b039968dcb6d7"></a><!-- doxytag: member="Wt::WResource::WResource" ref="b4a2f71811a597a3603b039968dcb6d7" args="(WObject *parent=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#b4a2f71811a597a3603b039968dcb6d7">WResource</a> (<a class="el" href="classWt_1_1WObject.html">WObject</a> *parent=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new resource. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#776c19c9bbc95330941744cd129bc01a">~WResource</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the resource.  <a href="#776c19c9bbc95330941744cd129bc01a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#8f2c3c2aa013cebecd73398dadc3d6d0">suggestFileName</a> (const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suggests a filename to the user for the data streamed by this resource.  <a href="#8f2c3c2aa013cebecd73398dadc3d6d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#966ece2e5a3e39d861e156ed0151402e">suggestedFileName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the suggested file name.  <a href="#966ece2e5a3e39d861e156ed0151402e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#9394f6c2ff6cadf8d1076ec52c5e909a">setChanged</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a new URL for this resource and emits the changed signal.  <a href="#9394f6c2ff6cadf8d1076ec52c5e909a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#06bb9dbe3ae195c320cfed7b062d448a">setInternalPath</a> (const std::string &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an internal path for this resource.  <a href="#06bb9dbe3ae195c320cfed7b062d448a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#ca0470f44682d5b785045269235a23b0">internalPath</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the internal path.  <a href="#ca0470f44682d5b785045269235a23b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#5060efcabde5f793c9d44c5ca557417d">generateUrl</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an URL for this resource.  <a href="#5060efcabde5f793c9d44c5ca557417d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#11169bf885f297f6f2ebbc1789aeded2">url</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current URL for this resource.  <a href="#11169bf885f297f6f2ebbc1789aeded2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classWt_1_1Signal.html">Signal</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#1527418354a584790c372e86a40c6027">dataChanged</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a> emitted when the data presented in this resource has changed.  <a href="#1527418354a584790c372e86a40c6027"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#d8bbe65a888cc43e0d356f18509b9a0f">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceWt_1_1Http.html#3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a> &amp;parameters=<a class="el" href="namespaceWt_1_1Http.html#3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a>(), const <a class="el" href="namespaceWt_1_1Http.html#c64df8f505cd5cf04b74c86d061b1f53">Http::UploadedFileMap</a> &amp;files=<a class="el" href="namespaceWt_1_1Http.html#c64df8f505cd5cf04b74c86d061b1f53">Http::UploadedFileMap</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream the resource to a stream.  <a href="#d8bbe65a888cc43e0d356f18509b9a0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#3a740f8cc29e2e6e4e58defc9c88b8b6">handleRequest</a> (const <a class="el" href="classWt_1_1Http_1_1Request.html">Http::Request</a> &amp;request, <a class="el" href="classWt_1_1Http_1_1Response.html">Http::Response</a> &amp;response)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles a request.  <a href="#3a740f8cc29e2e6e4e58defc9c88b8b6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#24f65859427f54012fef2fa9da14870d">beingDeleted</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares the resource for deletion.  <a href="#24f65859427f54012fef2fa9da14870d"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An object which can be rendered in the HTTP protocol. 
<p>
<h3>Usage</h3>
<p>
Besides the main page, other objects may be rendered as additional resources, for example documents or images. Classes such as <a class="el" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents).">WAnchor</a> or <a class="el" href="classWt_1_1WImage.html" title="A widget that displays an image.">WImage</a> can use a resource instead of a URL to provide their contents. Whenever the resource has changed, you should call the <a class="el" href="classWt_1_1WResource.html#9394f6c2ff6cadf8d1076ec52c5e909a" title="Generates a new URL for this resource and emits the changed signal.">setChanged()</a> method. <a class="el" href="classWt_1_1WResource.html#9394f6c2ff6cadf8d1076ec52c5e909a" title="Generates a new URL for this resource and emits the changed signal.">setChanged()</a> will make sure that the browser will use a new version of the resource by generating a new URL, and emits the <a class="el" href="classWt_1_1WResource.html#1527418354a584790c372e86a40c6027" title="Signal emitted when the data presented in this resource has changed.">dataChanged()</a> signal to make those that refer to the resource aware that they should update their references to the new URL.<p>
You can help the browser to start a suitable helper application to handle the downloaded resource, or suggest to the user a suitable filename for saving the resource, by setting an appropriate file name using <a class="el" href="classWt_1_1WResource.html#8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName()</a>.<p>
To serve resources that you create on the fly, you need to specialize this class and implement <a class="el" href="classWt_1_1WResource.html#3a740f8cc29e2e6e4e58defc9c88b8b6" title="Handles a request.">handleRequest()</a>.<p>
Example for a custom resource implementation: <div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyResource : <span class="keyword">public</span> Wt::<a class="code" href="classWt_1_1WResource.html#b4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>
 {
 <span class="keyword">public</span>:
   MyResource(<a class="code" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">Wt::WObject</a> *parent = 0)
     : Wt::<a class="code" href="classWt_1_1WResource.html#b4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>(parent)
   {
     <a class="code" href="classWt_1_1WResource.html#8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName</a>(<span class="stringliteral">"data.txt"</span>);
   }

   ~MyResource() {
     <a class="code" href="classWt_1_1WResource.html#24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted</a>(); <span class="comment">// see "Concurrency issues" below.</span>
   }

   <span class="keywordtype">void</span> <a class="code" href="classWt_1_1WResource.html#3a740f8cc29e2e6e4e58defc9c88b8b6" title="Handles a request.">handleRequest</a>(<span class="keyword">const</span> <a class="code" href="classWt_1_1Http_1_1Request.html" title="An HTTP request.">Wt::Http::Request</a>&amp; request,
                      <a class="code" href="classWt_1_1Http_1_1Response.html" title="An HTTP response.">Wt::Http::Response</a>&amp; response) {
     response.<a class="code" href="classWt_1_1Http_1_1Response.html#20dd49d512ffc0cf407f9dd39db30341" title="Set the content mime type.">setMimeType</a>(<span class="stringliteral">"plain/text"</span>);
     response.<a class="code" href="classWt_1_1Http_1_1Response.html#e74ee0009e9ec4aa3d3f35e680a745de" title="Returns the stream for getting the response output.">out</a>() &lt;&lt; <span class="stringliteral">"I am a text file."</span> &lt;&lt; std::endl;
   }
 };
</pre></div><p>
<h3>Concurrency issues</h3>
<p>
Because of the nature of the web, a resource may be requested one time or multiple times at the discretion of the browser, and therefore your resource should in general not have any side-effects except for what is needed to render its own contents. Unlike event notifications to a Wt application, resource requests are not serialized, but are handled concurrently. You need to grab the application lock if you want to access or modify other widget state from within the resource. When deleting a resource, any pending request is cancelled first. For this mechanism to work you need to specialize the destructor and call <a class="el" href="classWt_1_1WResource.html#24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted()</a>. This method may safely be called multiple times (i.e. from within each destructor in the hierachy).<p>
<h3>Continuations for asynchronous I/O</h3>
<p>
With respect to I/O, the current strategy is to cache the whole response first in a buffer and use async I/O to push the data to the client, in order to free the thread while waiting for I/O on a possibly slow link. You do not necessarily have to provide all output at once, instead you can obtain a <a class="el" href="classWt_1_1Http_1_1ResponseContinuation.html" title="A response continuation object.">Http::ResponseContinuation</a> object for a response, construct the response piecewise. A new request() will be made to continue the response.<p>
Example for a custom resource implementation using continuations: <div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyResource : <span class="keyword">public</span> Wt::<a class="code" href="classWt_1_1WResource.html#b4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>
 {
 <span class="keyword">public</span>:
   MyResource(<span class="keywordtype">int</span> iterations, <a class="code" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">Wt::WObject</a> *parent = 0)
     : Wt::<a class="code" href="classWt_1_1WResource.html#b4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>(parent)
     : iterations_(iterations)
   {
     <a class="code" href="classWt_1_1WResource.html#8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName</a>(<span class="stringliteral">"data.txt"</span>);
   }

   ~MyResource() {
     <a class="code" href="classWt_1_1WResource.html#24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted</a>();
   }

   <span class="keywordtype">void</span> <a class="code" href="classWt_1_1WResource.html#3a740f8cc29e2e6e4e58defc9c88b8b6" title="Handles a request.">handleRequest</a>(<span class="keyword">const</span> <a class="code" href="classWt_1_1Http_1_1Request.html" title="An HTTP request.">Wt::Http::Request</a>&amp; request,
                      <span class="keyword">const</span> <a class="code" href="classWt_1_1Http_1_1Response.html" title="An HTTP response.">Wt::Http::Response</a>&amp; response) {
     <span class="comment">// see if this request is for a continuation:</span>
     <a class="code" href="classWt_1_1Http_1_1ResponseContinuation.html" title="A response continuation object.">Wt::Http::ResponseContinuation</a> *continuation = request.<a class="code" href="classWt_1_1Http_1_1Request.html#2d4f88961a222be846460a8238823ae0" title="Returns a continuation object.">continuation</a>();

     <span class="comment">// calculate the current start</span>
     <span class="keywordtype">int</span> iteration = continuation ? boost::any_cast&lt;<span class="keywordtype">int</span>&gt;(continuation-&gt;<a class="code" href="classWt_1_1Http_1_1ResponseContinuation.html#92a3eb825c3df18ba5a6788315b8757b" title="Return data associated with the continuation.">data</a>()) : 0;
     <span class="keywordflow">if</span> (iteration == 0)
       response.<a class="code" href="classWt_1_1Http_1_1Response.html#20dd49d512ffc0cf407f9dd39db30341" title="Set the content mime type.">setMimeType</a>(<span class="stringliteral">"plain/text"</span>);

     <span class="keywordtype">int</span> last = std::min(iterations_, iteration + 100);
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = iteration; i &lt; last; ++i)
       response.<a class="code" href="classWt_1_1Http_1_1Response.html#e74ee0009e9ec4aa3d3f35e680a745de" title="Returns the stream for getting the response output.">out</a>() &lt;&lt; <span class="stringliteral">"Data item "</span> &lt;&lt; i &lt;&lt; std::endl;

     <span class="comment">// if we have not yet finished, create a continuation to serve more</span>
     <span class="keywordflow">if</span> (last &lt; iterations_)
       continuation = response.<a class="code" href="classWt_1_1Http_1_1Response.html#5cb0800718188328fec17d3b84c85aab" title="Create a continuation object for this response.">createContinuation</a>();
       <span class="comment">// remember what to do next</span>
       continuation-&gt;<a class="code" href="classWt_1_1Http_1_1ResponseContinuation.html#72fa6895f798e1270aa6e6a44222a9eb" title="Set data associated with the continuation.">setData</a>(last);
     }
   }

 <span class="keyword">private</span>:
   <span class="keywordtype">int</span> iterations_;
 };
</pre></div><p>
<h3>Global and private resources</h3>
<p>
By default, a resource is private to an application: access to it is protected by same secret session Id that protects any other access to the application.<p>
You can also deploy static resources, which are global, using <a class="el" href="classWt_1_1WServer.html#7b78b5e35d2dc3086faa54f82124cf38" title="Binds a resource to a fixed path.">WServer::addResource()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents).">WAnchor</a>, <a class="el" href="classWt_1_1WImage.html" title="A widget that displays an image.">WImage</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="776c19c9bbc95330941744cd129bc01a"></a><!-- doxytag: member="Wt::WResource::~WResource" ref="776c19c9bbc95330941744cd129bc01a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wt::WResource::~WResource           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the resource. 
<p>
When specializing a resource, you MUST call <a class="el" href="classWt_1_1WResource.html#24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted()</a> from within the specialized destructor, in order to stop any further requests to the resource. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8f2c3c2aa013cebecd73398dadc3d6d0"></a><!-- doxytag: member="Wt::WResource::suggestFileName" ref="8f2c3c2aa013cebecd73398dadc3d6d0" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::suggestFileName           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suggests a filename to the user for the data streamed by this resource. 
<p>
For resources, intended to be downloaded by the user, suggest a name used for saving. The filename extension may also help the browser to identify the correct program for opening the resource. 
</div>
</div><p>
<a class="anchor" name="966ece2e5a3e39d861e156ed0151402e"></a><!-- doxytag: member="Wt::WResource::suggestedFileName" ref="966ece2e5a3e39d861e156ed0151402e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Wt::WResource::suggestedFileName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the suggested file name. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WResource.html#8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName()</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="9394f6c2ff6cadf8d1076ec52c5e909a"></a><!-- doxytag: member="Wt::WResource::setChanged" ref="9394f6c2ff6cadf8d1076ec52c5e909a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::setChanged           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates a new URL for this resource and emits the changed signal. 
<p>
This does not work when the resource is deployed at an internal path using <a class="el" href="classWt_1_1WResource.html#06bb9dbe3ae195c320cfed7b062d448a" title="Sets an internal path for this resource.">setInternalPath()</a>. 
</div>
</div><p>
<a class="anchor" name="06bb9dbe3ae195c320cfed7b062d448a"></a><!-- doxytag: member="Wt::WResource::setInternalPath" ref="06bb9dbe3ae195c320cfed7b062d448a" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::setInternalPath           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an internal path for this resource. 
<p>
Using this method you can deploy the resource at a fixed path. Unless you deploy using cookies for session tracking (not recommended), a session identifier will be appended to the path.<p>
You should use internal paths that are different from internal paths handled by your application (<a class="el" href="classWt_1_1WApplication.html#2c1a10aadc0d7ed877b5715b42ca4911" title="Change the internal path.">WApplication::setInternalPath()</a>), if you do not want a conflict between these two when the browser does not use AJAX (and thus url fragments for its internal paths).<p>
The default value is empty. By default the URL for a resource is unspecified and a URL will be generated by the library.<p>
The internal path for a static resource is the deployment path specified using <a class="el" href="classWt_1_1WServer.html#7b78b5e35d2dc3086faa54f82124cf38" title="Binds a resource to a fixed path.">WServer::addResource()</a>. 
</div>
</div><p>
<a class="anchor" name="ca0470f44682d5b785045269235a23b0"></a><!-- doxytag: member="Wt::WResource::internalPath" ref="ca0470f44682d5b785045269235a23b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Wt::WResource::internalPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the internal path. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WResource.html#06bb9dbe3ae195c320cfed7b062d448a" title="Sets an internal path for this resource.">setInternalPath()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5060efcabde5f793c9d44c5ca557417d"></a><!-- doxytag: member="Wt::WResource::generateUrl" ref="5060efcabde5f793c9d44c5ca557417d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Wt::WResource::generateUrl           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates an URL for this resource. 
<p>
Generates a new url that refers to this resource. The url is unique to assure that it is not cached by the web browser, and can thus be used to refer to a new "version" of the resource, which can be indicated by emitting the <a class="el" href="classWt_1_1WResource.html#1527418354a584790c372e86a40c6027" title="Signal emitted when the data presented in this resource has changed.">dataChanged()</a> signal.<p>
The old urls are not invalidated by calling this method. 
</div>
</div><p>
<a class="anchor" name="11169bf885f297f6f2ebbc1789aeded2"></a><!-- doxytag: member="Wt::WResource::url" ref="11169bf885f297f6f2ebbc1789aeded2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Wt::WResource::url           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current URL for this resource. 
<p>
Returns the url that references this resource. 
</div>
</div><p>
<a class="anchor" name="1527418354a584790c372e86a40c6027"></a><!-- doxytag: member="Wt::WResource::dataChanged" ref="1527418354a584790c372e86a40c6027" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Signal.html">Signal</a>&amp; Wt::WResource::dataChanged           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a> emitted when the data presented in this resource has changed. 
<p>
Widgets that reference the resource (such as anchors and images) will make sure the new data is rendered.<p>
It is better to call <a class="el" href="classWt_1_1WResource.html#9394f6c2ff6cadf8d1076ec52c5e909a" title="Generates a new URL for this resource and emits the changed signal.">setChanged()</a> than to emit this signal. setChanged generates a new URL for this resource to avoid caching problems and then emits this signal. 
</div>
</div><p>
<a class="anchor" name="d8bbe65a888cc43e0d356f18509b9a0f"></a><!-- doxytag: member="Wt::WResource::write" ref="d8bbe65a888cc43e0d356f18509b9a0f" args="(std::ostream &amp;out, const Http::ParameterMap &amp;parameters=Http::ParameterMap(), const Http::UploadedFileMap &amp;files=Http::UploadedFileMap())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::write           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWt_1_1Http.html#3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em> = <code><a class="el" href="namespaceWt_1_1Http.html#3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWt_1_1Http.html#c64df8f505cd5cf04b74c86d061b1f53">Http::UploadedFileMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>files</em> = <code><a class="el" href="namespaceWt_1_1Http.html#c64df8f505cd5cf04b74c86d061b1f53">Http::UploadedFileMap</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stream the resource to a stream. 
<p>
This is a convenience method to serialize to a stream (for example a file stream). 
</div>
</div><p>
<a class="anchor" name="3a740f8cc29e2e6e4e58defc9c88b8b6"></a><!-- doxytag: member="Wt::WResource::handleRequest" ref="3a740f8cc29e2e6e4e58defc9c88b8b6" args="(const Http::Request &amp;request, Http::Response &amp;response)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wt::WResource::handleRequest           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Http_1_1Request.html">Http::Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1Http_1_1Response.html">Http::Response</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>response</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles a request. 
<p>
Reimplement this method so that a proper response is generated for the given request. From the <code>request</code> object you can access request parameters and whether the request is a continuation request. In the <code>response</code> object, you should set the mime type and stream the output data.<p>
A request may also concern a continuation, indicated in <a class="el" href="classWt_1_1Http_1_1Request.html#2d4f88961a222be846460a8238823ae0" title="Returns a continuation object.">Http::Request::continuation()</a>, in which case the next part for a previously created continuation should be served.<p>
While handling a request, which may happen at any time together with event handling, the library makes sure that the resource is not being concurrently deleted, but multiple requests may happend simultaneously for a single resource. 
<p>Implemented in <a class="el" href="classWt_1_1Ext_1_1DataStore.html#95828fc3362ef58ff821790180bf9834">Wt::Ext::DataStore</a>, <a class="el" href="classWt_1_1WFileResource.html#7a801fa115d455a2b8cc29938a29fe85">Wt::WFileResource</a>, <a class="el" href="classWt_1_1WMemoryResource.html#7800a19988ddf5af4e4ffe0f323316ae">Wt::WMemoryResource</a>, <a class="el" href="classWt_1_1WPdfImage.html#358347b05123b87af1ced8d038b34f38">Wt::WPdfImage</a>, <a class="el" href="classWt_1_1WRasterImage.html#636543ffb0fffeb7a9e0dd8a166d3167">Wt::WRasterImage</a>, and <a class="el" href="classWt_1_1WSvgImage.html#e79007c08cab7b4c9f24f0e0210c02e1">Wt::WSvgImage</a>.</p>

</div>
</div><p>
<a class="anchor" name="24f65859427f54012fef2fa9da14870d"></a><!-- doxytag: member="Wt::WResource::beingDeleted" ref="24f65859427f54012fef2fa9da14870d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::beingDeleted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepares the resource for deletion. 
<p>
When specializing a resource, you MUST call <a class="el" href="classWt_1_1WResource.html#24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted()</a> from within the specialized destructor, in order to stop any further requests to the resource. 
</div>
</div><p>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Fri Sep 10 16:33:03 2010 for <a href="http://www.webtoolkit.eu/wt/">Wt</a> by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
