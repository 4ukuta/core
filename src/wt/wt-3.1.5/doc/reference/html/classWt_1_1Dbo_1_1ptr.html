<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Wt: Wt::Dbo::ptr&lt; C &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceWt.html">Wt</a>::<a class="el" href="namespaceWt_1_1Dbo.html">Dbo</a>::<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>
  </div>
</div>
<div class="contents">
<h1>Wt::Dbo::ptr&lt; C &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__dbo.html">Database Objects (Dbo)</a>]</small>
</h1><!-- doxytag: class="Wt::Dbo::ptr" --><!-- doxytag: inherits="Wt::Dbo::ptr_base" -->A smart pointer for database objects.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Wt/Dbo/ptr&gt;</code>
<p>
Inherits Wt::Dbo::ptr_base.
<p>

<p>
<a href="classWt_1_1Dbo_1_1ptr-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#55cf9170cd012a15df206ac54178da3a">ptr</a> (C *obj=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new pointer.  <a href="#55cf9170cd012a15df206ac54178da3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8cdf1ba27d9b31cb03c37d16ded0776"></a><!-- doxytag: member="Wt::Dbo::ptr::ptr" ref="e8cdf1ba27d9b31cb03c37d16ded0776" args="(const ptr&lt; C &gt; &amp;other)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#e8cdf1ba27d9b31cb03c37d16ded0776">ptr</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#8ba24bdad5f3536eabe1a378d3d2bdec">~ptr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#8ba24bdad5f3536eabe1a378d3d2bdec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a93933be1dde5b88f8220fd578e0714e">reset</a> (C *obj=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the pointer.  <a href="#a93933be1dde5b88f8220fd578e0714e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8ea4ded2103a4ec31306549cbbf74f5"></a><!-- doxytag: member="Wt::Dbo::ptr::operator=" ref="f8ea4ded2103a4ec31306549cbbf74f5" args="(const ptr&lt; C &gt; &amp;other)" -->
<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#f8ea4ded2103a4ec31306549cbbf74f5">operator=</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const C *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#fe3605c8c5d46ddd078775275fb0cbc9">operator-&gt;</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference operator.  <a href="#fe3605c8c5d46ddd078775275fb0cbc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const C &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#6cabfa29875c40ce04e57c71df406e9a">operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference operator.  <a href="#6cabfa29875c40ce04e57c71df406e9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">C *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#8f9f4ec6ed2bd8febe8b62525c9576da">modify</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference operator, for writing.  <a href="#8f9f4ec6ed2bd8febe8b62525c9576da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#6992f0c852b65dfe6be35a88dc880e45">operator==</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="#6992f0c852b65dfe6be35a88dc880e45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#4c283ff5e8d099e92d1ed0fcdeaecf16">operator&lt;</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="#4c283ff5e8d099e92d1ed0fcdeaecf16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a8c343715b6fafc63d34f2af7419f267">operator bool</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for null.  <a href="#a8c343715b6fafc63d34f2af7419f267"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af91f5ef8bcdabfafcd9abb4182625bd">flush</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flushes the object.  <a href="#af91f5ef8bcdabfafcd9abb4182625bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#f4b26afebd56abc42005ef9f954d8fee">remove</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an object from the database.  <a href="#f4b26afebd56abc42005ef9f954d8fee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#bb1db71ef910748437d69bf11a04eb6e">reread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rereads the database version.  <a href="#bb1db71ef910748437d69bf11a04eb6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#7330a5220e3e926b5c084444116499a4">purge</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Purges an object from memory.  <a href="#7330a5220e3e926b5c084444116499a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structWt_1_1Dbo_1_1dbo__traits.html">dbo_traits</a>&lt; C &gt;::IdType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#71d848cf0e8eaa1a4e01b11ae2f1e865">id</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the object id.  <a href="#71d848cf0e8eaa1a4e01b11ae2f1e865"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#5c907971ba36fa3c5145b683abc76c76">version</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the object version.  <a href="#5c907971ba36fa3c5145b683abc76c76"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class C&gt;<br>
 class Wt::Dbo::ptr&lt; C &gt;</h3>

A smart pointer for database objects. 
<p>
This smart pointer class implements a reference counted shared pointer for database objects, which also keeps tracking of synchronization between the in-memory copy and the database copy. You should always use this pointer class to reference a database object.<p>
Unlike typical C++ data structures, classes mapped to database tables do not have clear ownership relationships. Therefore, the conventional ownership-based memory allocation/deallocation does not work naturally for database classes.<p>
A pointer may point to a <em>transient</em> object or a <em>persisted</em> object. A persisted object has a corresponding copy in the database while a transient object is only present in memory. To persist a new object, use <a class="el" href="classWt_1_1Dbo_1_1Session.html#1ffa672cd86ff1ce6d59837b05081946" title="Persists a transient object.">Session::add()</a>. To make a persisted object transient, use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#f4b26afebd56abc42005ef9f954d8fee" title="Removes an object from the database.">remove()</a>.<p>
Unlike a typical smart pointer, this pointer only allows read access to the underlying object by default. To modify the object, you should explicitly use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#8f9f4ec6ed2bd8febe8b62525c9576da" title="Dereference operator, for writing.">modify()</a>. This is used to mark the underyling object as <em>dirty</em> to add it to the queue of objects to be synchronized with the database.<p>
The pointer class provides a number of methods to deal with the persistence state of the object:<ul>
<li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#71d848cf0e8eaa1a4e01b11ae2f1e865" title="Returns the object id.">id()</a>: returns the database id</li><li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af91f5ef8bcdabfafcd9abb4182625bd" title="Flushes the object.">flush()</a>: forces the object to be synchronized to the database</li><li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#f4b26afebd56abc42005ef9f954d8fee" title="Removes an object from the database.">remove()</a>: deletes the object in the underlying database</li><li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#bb1db71ef910748437d69bf11a04eb6e" title="Rereads the database version.">reread()</a>: rereads the database copy of the object</li><li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#7330a5220e3e926b5c084444116499a4" title="Purges an object from memory.">purge()</a>: purges the transient version of a non-dirty object. </li></ul>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="55cf9170cd012a15df206ac54178da3a"></a><!-- doxytag: member="Wt::Dbo::ptr::ptr" ref="55cf9170cd012a15df206ac54178da3a" args="(C *obj=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>obj</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new pointer. 
<p>
When <code>obj</code> is not 0, the pointer points to the new unpersisted object. Use <a class="el" href="classWt_1_1Dbo_1_1Session.html#1ffa672cd86ff1ce6d59837b05081946" title="Persists a transient object.">Session::add()</a> to persist the newly created object. 
</div>
</div><p>
<a class="anchor" name="8ba24bdad5f3536eabe1a378d3d2bdec"></a><!-- doxytag: member="Wt::Dbo::ptr::~ptr" ref="8ba24bdad5f3536eabe1a378d3d2bdec" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::~<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
This method will delete the transient copy of the database object if it is not referenced by any other pointer. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a93933be1dde5b88f8220fd578e0714e"></a><!-- doxytag: member="Wt::Dbo::ptr::reset" ref="a93933be1dde5b88f8220fd578e0714e" args="(C *obj=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::reset           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>obj</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the pointer. 
<p>
This is equivalent to: <div class="fragment"><pre class="fragment"> p = ptr&lt;C&gt;(obj);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="fe3605c8c5d46ddd078775275fb0cbc9"></a><!-- doxytag: member="Wt::Dbo::ptr::operator-&gt;" ref="fe3605c8c5d46ddd078775275fb0cbc9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const C * <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator-&gt;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereference operator. 
<p>
Note that this operator returns a const copy of the referenced object. Use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#8f9f4ec6ed2bd8febe8b62525c9576da" title="Dereference operator, for writing.">modify()</a> to get a non-const reference.<p>
Since this may lazy-load the underlying database object, you should have an active transaction. 
</div>
</div><p>
<a class="anchor" name="6cabfa29875c40ce04e57c71df406e9a"></a><!-- doxytag: member="Wt::Dbo::ptr::operator*" ref="6cabfa29875c40ce04e57c71df406e9a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const C &amp; <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator*           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereference operator. 
<p>
Note that this operator returns a const copy of the referenced object. Use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#8f9f4ec6ed2bd8febe8b62525c9576da" title="Dereference operator, for writing.">modify()</a> to get a non-const reference.<p>
Since this may lazy-load the underlying database object, you should have an active transaction. 
</div>
</div><p>
<a class="anchor" name="8f9f4ec6ed2bd8febe8b62525c9576da"></a><!-- doxytag: member="Wt::Dbo::ptr::modify" ref="8f9f4ec6ed2bd8febe8b62525c9576da" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C * <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::modify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereference operator, for writing. 
<p>
Returns the underlying object with the intention to modify it. It marks the underlying object as dirty.<p>
Since this may lazy-load the underlying database object, you should have an active transaction. 
</div>
</div><p>
<a class="anchor" name="6992f0c852b65dfe6be35a88dc880e45"></a><!-- doxytag: member="Wt::Dbo::ptr::operator==" ref="6992f0c852b65dfe6be35a88dc880e45" args="(const ptr&lt; C &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison operator. 
<p>
Two pointers are equal if and only if they reference the same databse object. 
</div>
</div><p>
<a class="anchor" name="4c283ff5e8d099e92d1ed0fcdeaecf16"></a><!-- doxytag: member="Wt::Dbo::ptr::operator&lt;" ref="4c283ff5e8d099e92d1ed0fcdeaecf16" args="(const ptr&lt; C &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison operator. 
<p>
This operator is implemented to be able to store pointers in std::set or std::map containers. 
</div>
</div><p>
<a class="anchor" name="a8c343715b6fafc63d34f2af7419f267"></a><!-- doxytag: member="Wt::Dbo::ptr::operator bool" ref="a8c343715b6fafc63d34f2af7419f267" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator bool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for null. 
<p>
Returns true if the pointer is pointing to a non-null object. 
</div>
</div><p>
<a class="anchor" name="af91f5ef8bcdabfafcd9abb4182625bd"></a><!-- doxytag: member="Wt::Dbo::ptr::flush" ref="af91f5ef8bcdabfafcd9abb4182625bd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::flush           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flushes the object. 
<p>
If dirty, the object is synchronized to the database. This will automatically also flush objects that are referenced by this object if needed. The object is not actually committed to the database before the active transaction has been committed.<p>
Since this may persist object to the database, you should have an active transaction. 
</div>
</div><p>
<a class="anchor" name="f4b26afebd56abc42005ef9f954d8fee"></a><!-- doxytag: member="Wt::Dbo::ptr::remove" ref="f4b26afebd56abc42005ef9f954d8fee" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::remove           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an object from the database. 
<p>
The object is removed from the database, and becomes transient again.<p>
Note that the object is not deleted in memory: you can still continue to read and modify the object, but there will no longer be a database copy of the object, and the object will effectively be treated as a new object (which may be re-added to the database at a later point).<p>
This is the opposite operation of <a class="el" href="classWt_1_1Dbo_1_1Session.html#1ffa672cd86ff1ce6d59837b05081946" title="Persists a transient object.">Session::add()</a>. 
</div>
</div><p>
<a class="anchor" name="bb1db71ef910748437d69bf11a04eb6e"></a><!-- doxytag: member="Wt::Dbo::ptr::reread" ref="bb1db71ef910748437d69bf11a04eb6e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::reread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rereads the database version. 
<p>
Rereads a persisted object from the database, discarding any possible changes and updating to the latest database version.<p>
This does not actually load the database version, since loading is lazy. 
</div>
</div><p>
<a class="anchor" name="7330a5220e3e926b5c084444116499a4"></a><!-- doxytag: member="Wt::Dbo::ptr::purge" ref="7330a5220e3e926b5c084444116499a4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::purge           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Purges an object from memory. 
<p>
When the object is not dirty, the memory copy of the object is deleted, and the object will be reread from the database on the next access.<p>
Purging an object can be useful to conserve memory, but you should never purge an object while the user is editing if you wish to rely on the optimistick locking for detecting concurrent modifications. 
</div>
</div><p>
<a class="anchor" name="71d848cf0e8eaa1a4e01b11ae2f1e865"></a><!-- doxytag: member="Wt::Dbo::ptr::id" ref="71d848cf0e8eaa1a4e01b11ae2f1e865" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structWt_1_1Dbo_1_1dbo__traits.html">dbo_traits</a>&lt; C &gt;::IdType <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::id           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the object id. 
<p>
This returns <a class="el" href="structWt_1_1Dbo_1_1dbo__traits.html#ae2a13a4ca038f5bad337fbc2d70d37c" title="Returns the sentinel value for a null id.">dbo_traits&lt;C&gt;::invalidId()</a> for a transient object. 
</div>
</div><p>
<a class="anchor" name="5c907971ba36fa3c5145b683abc76c76"></a><!-- doxytag: member="Wt::Dbo::ptr::version" ref="5c907971ba36fa3c5145b683abc76c76" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::version           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the object version. 
<p>
This returns -1 for a transient object or when versioning is not enabled. 
</div>
</div><p>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Fri Sep 10 16:33:04 2010 for <a href="http://www.webtoolkit.eu/wt/">Wt</a> by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
