<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Wt: Wt::WContainerWidget Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceWt.html">Wt</a>::<a class="el" href="classWt_1_1WContainerWidget.html">WContainerWidget</a>
  </div>
</div>
<div class="contents">
<h1>Wt::WContainerWidget Class Reference</h1><!-- doxytag: class="Wt::WContainerWidget" --><!-- doxytag: inherits="Wt::WInteractWidget" -->A widget that holds and manages child widgets.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Wt/WContainerWidget&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Wt::WContainerWidget:</div>
<div class="dynsection">
<p><center><img src="classWt_1_1WContainerWidget__inherit__graph.png" border="0" usemap="#Wt_1_1WContainerWidget__inherit__map" alt="Inheritance graph"></center>
<map name="Wt_1_1WContainerWidget__inherit__map">
<area shape="rect" href="classWt_1_1Ext_1_1Splitter.html" title="A container widget with resize handles between its children." alt="" coords="897,5,1012,35"><area shape="rect" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents)." alt="" coords="907,59,1003,88"><area shape="rect" href="classWt_1_1WGroupBox.html" title="A widget which group widgets into a frame with a title." alt="" coords="897,112,1012,141"><area shape="rect" href="classWt_1_1WOverlayLoadingIndicator.html" title="A more obvious loading indicator that grays the window." alt="" coords="857,165,1052,195"><area shape="rect" href="classWt_1_1WStackedWidget.html" title="A container widget that stacks its widgets on top of each other." alt="" coords="883,219,1027,248"><area shape="rect" href="classWt_1_1WTableCell.html" title="A container widget that represents a cell in a table." alt="" coords="900,272,1009,301"><area shape="rect" href="classWt_1_1WInteractWidget.html" title="An abstract widget that can receive user&#45;interface interaction." alt="" coords="467,139,608,168"><area shape="rect" href="classWt_1_1WWebWidget.html" title="A base class for widgets with an HTML counterpart." alt="" coords="296,139,419,168"><area shape="rect" href="classWt_1_1WWidget.html" title="The abstract base class for a user&#45;interface component." alt="" coords="151,139,247,168"><area shape="rect" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system." alt="" coords="7,139,100,168"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classWt_1_1WContainerWidget-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6">Overflow</a> { <a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6a195ca15f69167c8f3087e5bc3e24f68">OverflowVisible</a> = 0x0, 
<a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6c8fcc7d215f329753187326459cf5856">OverflowAuto</a> = 0x1, 
<a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6c5ba5a20547ae53b1caef3f05d0c3241">OverflowHidden</a> = 0x2, 
<a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d63c51faeacd0f1d2c6fa287f5e9932be9">OverflowScroll</a> = 0x3
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How to handle overflow of inner content.  <a href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="520ba6e52a36a7f2efbef1a31a69e898"></a><!-- doxytag: member="Wt::WContainerWidget::WContainerWidget" ref="520ba6e52a36a7f2efbef1a31a69e898" args="(WContainerWidget *parent=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#520ba6e52a36a7f2efbef1a31a69e898">WContainerWidget</a> (<a class="el" href="classWt_1_1WContainerWidget.html">WContainerWidget</a> *parent=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a container with optional parent. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bcdb141e27e673f10c8e0e693307bf94"></a><!-- doxytag: member="Wt::WContainerWidget::~WContainerWidget" ref="bcdb141e27e673f10c8e0e693307bf94" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#bcdb141e27e673f10c8e0e693307bf94">~WContainerWidget</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#1c84e0ffe330d4798f0ce217f75be08c">setLayout</a> (<a class="el" href="classWt_1_1WLayout.html">WLayout</a> *layout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a layout manager for the container.  <a href="#1c84e0ffe330d4798f0ce217f75be08c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#ff9884c8efdf90974077e96bcb1701db">setLayout</a> (<a class="el" href="classWt_1_1WLayout.html">WLayout</a> *layout, WFlags&lt; <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt; alignment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a layout manager for the container.  <a href="#ff9884c8efdf90974077e96bcb1701db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classWt_1_1WLayout.html">WLayout</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#faba82a27836f4a82bab48e8b26ccca2">layout</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the layout manager that was set for the container.  <a href="#faba82a27836f4a82bab48e8b26ccca2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#2cfe66d9b62940f889e99538a9f478d2">addWidget</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a child widget to this container.  <a href="#2cfe66d9b62940f889e99538a9f478d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#1439877a32c4b082f312fee81d139665">insertBefore</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget, <a class="el" href="classWt_1_1WWidget.html">WWidget</a> *before)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a child widget in this container, before another widget.  <a href="#1439877a32c4b082f312fee81d139665"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#15ffcecaf10e6f04ec5667d2b3f0d919">insertWidget</a> (int index, <a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a child widget in this container at given index.  <a href="#15ffcecaf10e6f04ec5667d2b3f0d919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#4292867b1872bd31c7d0c3346d988470">removeWidget</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a child widget from this container.  <a href="#4292867b1872bd31c7d0c3346d988470"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#608f748cbdda763f1a11556ddad9fbe1">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and deletes all child widgets.  <a href="#608f748cbdda763f1a11556ddad9fbe1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7cf9f4f1c261080bce30b6a6ea19014e"></a><!-- doxytag: member="Wt::WContainerWidget::indexOf" ref="7cf9f4f1c261080bce30b6a6ea19014e" args="(WWidget *widget) const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#7cf9f4f1c261080bce30b6a6ea19014e">indexOf</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of a widget. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53c79a7311ffe3c132b50bdbb830856d"></a><!-- doxytag: member="Wt::WContainerWidget::widget" ref="53c79a7311ffe3c132b50bdbb830856d" args="(int index) const " -->
virtual <a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#53c79a7311ffe3c132b50bdbb830856d">widget</a> (int index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the widget at <em>index</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="85abd4d928575717052ff7fa04c3c2c9"></a><!-- doxytag: member="Wt::WContainerWidget::count" ref="85abd4d928575717052ff7fa04c3c2c9" args="() const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#85abd4d928575717052ff7fa04c3c2c9">count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of widgets in this container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#ba13c9e62c74bcba53519ee9cf41f40a">setContentAlignment</a> (WFlags&lt; <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt; contentAlignment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies how child widgets must be aligned within the container.  <a href="#ba13c9e62c74bcba53519ee9cf41f40a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#fa5f6800e2170ae2f4586a25c72f8c34">setPadding</a> (const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;padding, WFlags&lt; <a class="el" href="namespaceWt.html#5a6f4636bcc6ab3c075165d249b3a5a3">Side</a> &gt; sides=<a class="el" href="namespaceWt.html#3358b8309fdb63a402efcb1a577855e8">All</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets padding inside the widget.  <a href="#fa5f6800e2170ae2f4586a25c72f8c34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classWt_1_1WLength.html">WLength</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#326a0c9d7e4307dfd9c6979a2c441a96">padding</a> (<a class="el" href="namespaceWt.html#5a6f4636bcc6ab3c075165d249b3a5a3">Side</a> side) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the padding set for the widget.  <a href="#326a0c9d7e4307dfd9c6979a2c441a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">WFlags&lt; <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#042dbe790f34279f1978bc87610933df">contentAlignment</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the alignment of children.  <a href="#042dbe790f34279f1978bc87610933df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#e269f870992c5843d3097a63795b10d6">setOverflow</a> (<a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6">Overflow</a> overflow, WFlags&lt; <a class="el" href="namespaceWt.html#2a8d45559e16a0185bf61bfad0a67912">Orientation</a> &gt; orientation=(Horizontal|Vertical))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets how overflow of contained children must be handled.  <a href="#e269f870992c5843d3097a63795b10d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#4b1857ba8e8a677887cd20aa657fb77f">setList</a> (bool list, bool ordered=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders the container as an HTML list.  <a href="#4b1857ba8e8a677887cd20aa657fb77f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#2ba1ccbc634a57f21608c410d28bbff5">isList</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if this container is rendered as a List.  <a href="#2ba1ccbc634a57f21608c410d28bbff5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#e0db17987ae260b71d860b8f670c0c8a">isUnorderedList</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if this container is rendered as an Unordered List.  <a href="#e0db17987ae260b71d860b8f670c0c8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#f7c9ba23a66d27cb7442557284464f3f">isOrderedList</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if this container is rendered as an Ordered List.  <a href="#f7c9ba23a66d27cb7442557284464f3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classWt_1_1EventSignal.html">EventSignal</a>&lt; <a class="el" href="classWt_1_1WScrollEvent.html">WScrollEvent</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#64b97ae076fc6d678305fcdf77738a31">scrolled</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event signal emitted when scrolling in the widget.  <a href="#64b97ae076fc6d678305fcdf77738a31"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A widget that holds and manages child widgets. 
<p>
A WContainerWidget acts as a container for child widgets. Child widgets may be added directly to the container or using a layout manager.<p>
Use <a class="el" href="classWt_1_1WContainerWidget.html#2cfe66d9b62940f889e99538a9f478d2" title="Adds a child widget to this container.">addWidget()</a> or pass the container as constructor argument to a widget to directly add children to the container, without using a layout manager. In that case, CSS-based layout is used, and the resulting display is determined by properties of the children and the container. By default, a WContainerWidget is displayed as a <a class="el" href="classWt_1_1WWidget.html#c78e3af143883334c82031790c87416e">block </a> and manages its children within a rectangle. Inline child widgets are layed out in lines, wrapping around as needed, while block child widgets are stacked vertically. The container may add padding at the container edges using <a class="el" href="classWt_1_1WContainerWidget.html#fa5f6800e2170ae2f4586a25c72f8c34" title="Sets padding inside the widget.">setPadding()</a>, and provide alignment of contents using <a class="el" href="classWt_1_1WContainerWidget.html#ba13c9e62c74bcba53519ee9cf41f40a" title="Specifies how child widgets must be aligned within the container.">setContentAlignment()</a>. A container is rendered by default using a HTML <code>div</code> tag, but this may be changed to an HTML <code>ul</code> or <code>ol</code> tag to make use of other CSS layout techniques, using <a class="el" href="classWt_1_1WContainerWidget.html#4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>. In addition, specializations of this class as implemented by <a class="el" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents).">WAnchor</a>, <a class="el" href="classWt_1_1WGroupBox.html" title="A widget which group widgets into a frame with a title.">WGroupBox</a>, <a class="el" href="classWt_1_1WStackedWidget.html" title="A container widget that stacks its widgets on top of each other.">WStackedWidget</a> and <a class="el" href="classWt_1_1WTableCell.html" title="A container widget that represents a cell in a table.">WTableCell</a> provide other alternative rendering of the container.<p>
When setting the WContainerWidget <a class="el" href="classWt_1_1WWidget.html#c78e3af143883334c82031790c87416e">inline </a> the container only acts as a conceptual container, offering a common style to its children. Inline children are still layed out inline within the flow of the parent container of this container, as if they were inserted directly into that parent container. Block children are then not allowed (according to the HTML specification).<p>
To use a layout manager instead of CSS-based layout, use <a class="el" href="classWt_1_1WContainerWidget.html#1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout()</a> or pass the container as constructor argument to a layout manager. In that case you should not define any padding for the container, and widgets and nested layout managers must be added to the layout manager, instead of to the container directly.<p>
Usage example:<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Example 1:</span>
 <span class="comment">// Instantiate a container widget and add some children whose layout </span>
 <span class="comment">// is governed based on HTML/CSS rules.</span>
 <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *container1 = <span class="keyword">new</span> <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a>();
 container1-&gt;<a class="code" href="classWt_1_1WContainerWidget.html#2cfe66d9b62940f889e99538a9f478d2" title="Adds a child widget to this container.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html" title="A widget that renders (XHTML) text.">Wt::WText</a>(<span class="stringliteral">"Some text"</span>));
 container1-&gt;<a class="code" href="classWt_1_1WContainerWidget.html#2cfe66d9b62940f889e99538a9f478d2" title="Adds a child widget to this container.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WImage.html" title="A widget that displays an image.">Wt::WImage</a>(<span class="stringliteral">"images/img.png"</span>));
 <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *child3 = <span class="keyword">new</span> <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a>(container1);

 <span class="comment">// Example 2:</span>
 <span class="comment">// Instantiate a container widget which uses a layout manager</span>
 <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *container2 = <span class="keyword">new</span> <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a>();
 container2-&gt;<a class="code" href="classWt_1_1WWebWidget.html#e1b84e31581405358b6d57ec14505234" title="Resizes the widget.">resize</a>(<a class="code" href="classWt_1_1WLength.html#0cf39ca4225776879d56ade60320c31a" title="An &amp;#39;auto&amp;#39; length.">WLength::Auto</a>, 600); <span class="comment">// give the container a fixed height.</span>

 <a class="code" href="classWt_1_1WVBoxLayout.html" title="A layout manager which arranges widgets vertically.">Wt::WVBoxLayout</a> *layout = <span class="keyword">new</span> <a class="code" href="classWt_1_1WVBoxLayout.html" title="A layout manager which arranges widgets vertically.">Wt::WVBoxLayout</a>();
 layout-&gt;<a class="code" href="classWt_1_1WBoxLayout.html#7c1ec58e25d0b7add93f5f4342844db6" title="Adds a widget to the layout.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html" title="A widget that renders (XHTML) text.">Wt::WText</a>(<span class="stringliteral">"Some text"</span>));
 layout-&gt;<a class="code" href="classWt_1_1WBoxLayout.html#7c1ec58e25d0b7add93f5f4342844db6" title="Adds a widget to the layout.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WImage.html" title="A widget that displays an image.">Wt::WImage</a>(<span class="stringliteral">"images/img.png"</span>));

 container2-&gt;<a class="code" href="classWt_1_1WContainerWidget.html#1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout</a>(layout);      <span class="comment">// set the layout to the container.</span>
</pre></div><p>
When using a layout manager, you need to carefully consider the alignment of the layout manager with respect to the container: when the container's height is unconstrained (not specified explicitly using <a class="el" href="classWt_1_1WWebWidget.html#e1b84e31581405358b6d57ec14505234" title="Resizes the widget.">resize()</a> or a style class, and the container is not included in a layout manager), you should pass AlignTop to <a class="el" href="classWt_1_1WContainerWidget.html#1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout()</a>.<p>
<h3>CSS</h3>
<p>
Depending on its configuration and usage, the widget corresponds to the following HTML tags:<ul>
<li>By default, the widget corresponds to a <code>&lt;div&gt;</code> tag.</li><li>When configured with setInline(true), the widget corresponds to a <code>&lt;span&gt;</code>.</li><li>When configured with setList(true), the widget corresponds to a <code>&lt;ul&gt;</code>.</li><li>When configured with setList(true, true), the widget corresponds to a <code>&lt;ol&gt;</code>.</li><li>When inserted into a container widget that <a class="el" href="classWt_1_1WContainerWidget.html#2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, the widget corresponds to a <code>&lt;li&gt;</code>.</li></ul>
<p>
This widget does not provide styling, and can be styled using inline or external CSS as appropriate. <hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="bcc1911965f1669b94bd3f8fbf86a2d6"></a><!-- doxytag: member="Wt::WContainerWidget::Overflow" ref="bcc1911965f1669b94bd3f8fbf86a2d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6">Wt::WContainerWidget::Overflow</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
How to handle overflow of inner content. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="bcc1911965f1669b94bd3f8fbf86a2d6a195ca15f69167c8f3087e5bc3e24f68"></a><!-- doxytag: member="OverflowVisible" ref="bcc1911965f1669b94bd3f8fbf86a2d6a195ca15f69167c8f3087e5bc3e24f68" args="" -->OverflowVisible</em>&nbsp;</td><td>
Show content that overflows. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="bcc1911965f1669b94bd3f8fbf86a2d6c8fcc7d215f329753187326459cf5856"></a><!-- doxytag: member="OverflowAuto" ref="bcc1911965f1669b94bd3f8fbf86a2d6c8fcc7d215f329753187326459cf5856" args="" -->OverflowAuto</em>&nbsp;</td><td>
Show scrollbars when needed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="bcc1911965f1669b94bd3f8fbf86a2d6c5ba5a20547ae53b1caef3f05d0c3241"></a><!-- doxytag: member="OverflowHidden" ref="bcc1911965f1669b94bd3f8fbf86a2d6c5ba5a20547ae53b1caef3f05d0c3241" args="" -->OverflowHidden</em>&nbsp;</td><td>
Hide content that overflows. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="bcc1911965f1669b94bd3f8fbf86a2d63c51faeacd0f1d2c6fa287f5e9932be9"></a><!-- doxytag: member="OverflowScroll" ref="bcc1911965f1669b94bd3f8fbf86a2d63c51faeacd0f1d2c6fa287f5e9932be9" args="" -->OverflowScroll</em>&nbsp;</td><td>
Always show scroll bars. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1c84e0ffe330d4798f0ce217f75be08c"></a><!-- doxytag: member="Wt::WContainerWidget::setLayout" ref="1c84e0ffe330d4798f0ce217f75be08c" args="(WLayout *layout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WLayout.html">WLayout</a> *&nbsp;</td>
          <td class="paramname"> <em>layout</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a layout manager for the container. 
<p>
Note that you can nest layout managers inside each other, to create a complex layout hierarchy.<p>
If a previous layout manager was already set, it is first deleted. In that case, you will need to make sure that you either readd all widgets that were part of the previous layout to the new layout, or delete them, to avoid memory leaks.<p>
The layout manager arranges children in the entire width and height of the container. This is equivalent to <a class="el" href="classWt_1_1WContainerWidget.html#ff9884c8efdf90974077e96bcb1701db">setLayout(layout, AlignJustify)</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#faba82a27836f4a82bab48e8b26ccca2" title="Returns the layout manager that was set for the container.">layout()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#ff9884c8efdf90974077e96bcb1701db" title="Sets a layout manager for the container.">setLayout(WLayout *, WFlags&lt;AlignmentFlag&gt;)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WWidget.html">Wt::WWidget</a>.</p>

</div>
</div><p>
<a class="anchor" name="ff9884c8efdf90974077e96bcb1701db"></a><!-- doxytag: member="Wt::WContainerWidget::setLayout" ref="ff9884c8efdf90974077e96bcb1701db" args="(WLayout *layout, WFlags&lt; AlignmentFlag &gt; alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WLayout.html">WLayout</a> *&nbsp;</td>
          <td class="paramname"> <em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a layout manager for the container. 
<p>
The <code>alignment</code> argument determines how the layout is aligned inside the container. By default, the layout manager arranges children over the entire width and height of the container, corresponding to a value of AlignJustify. This requires that the container has a specified height (either because it is managed by another layout manager, is the root container widget, or has a height set).<p>
In general, <code>alignment</code> is the logical OR of a horizontal and a vertical flag:<ul>
<li>The horizontal alignment option may be one of <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143fd033ef69b45d0b75633be34168c9b606" title="Align to the left.">Wt::AlignLeft</a>, <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f121104cdbb5db77c7d038813a93998e5" title="Align horizontally in the center.">Wt::AlignCenter</a>, <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143fb250310385383f0b2f68d4e0ad5567e1" title="Align to the right.">Wt::AlignRight</a>, or <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f18cdf9d975a5a41afa182aabfde0de88" title="Justify left and right.">Wt::AlignJustify</a>.</li><li>The vertical alignment option may be '0' (corresponding to vertical justification to the full height), or <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f58fe5182bd266132c59718c6d30945a9" title="Align top of widget with top of tallest sibling widget.">Wt::AlignTop</a>.</li></ul>
<p>
When using a horizontal alingment different from <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f18cdf9d975a5a41afa182aabfde0de88" title="Justify left and right.">Wt::AlignJustify</a>, and a vertical alignment different from '0', the widget is sized in that direction to fit the contents, instead of the contents being adjusted to the widget size. This is useful when the container does not have a specific size in that direction and when the layout manager does not contain any widgets that wish to consume all remaining space in that direction.<p>
Only a single layout manager may be set. If you want to replace the current layout manager, you have to erase all contents first using <a class="el" href="classWt_1_1WContainerWidget.html#608f748cbdda763f1a11556ddad9fbe1" title="Removes and deletes all child widgets.">clear()</a>, which also deletes the layout manager.<p>
Note that you can nest layout managers inside each other, to create a complex layout hierarchy.<p>
The widget will take ownership of <code>layout</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#faba82a27836f4a82bab48e8b26ccca2" title="Returns the layout manager that was set for the container.">layout()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="faba82a27836f4a82bab48e8b26ccca2"></a><!-- doxytag: member="Wt::WContainerWidget::layout" ref="faba82a27836f4a82bab48e8b26ccca2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WLayout.html">WLayout</a>* Wt::WContainerWidget::layout           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the layout manager that was set for the container. 
<p>
If no layout manager was previously set using setLayout(<a class="el" href="classWt_1_1WLayout.html" title="An abstract base class for layout managers.">WLayout</a> *), 0 is returned.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout(WLayout *)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WWidget.html">Wt::WWidget</a>.</p>

</div>
</div><p>
<a class="anchor" name="2cfe66d9b62940f889e99538a9f478d2"></a><!-- doxytag: member="Wt::WContainerWidget::addWidget" ref="2cfe66d9b62940f889e99538a9f478d2" args="(WWidget *widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::addWidget           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&nbsp;</td>
          <td class="paramname"> <em>widget</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a child widget to this container. 
<p>
This is equivalent to passing this container as the parent when constructing the child. The widget is appended to the list of children, and thus also layed-out at the end. 
<p>Reimplemented in <a class="el" href="classWt_1_1Ext_1_1Splitter.html#3f776ab5a6c84ebfa1d4896b475fec7a">Wt::Ext::Splitter</a>, and <a class="el" href="classWt_1_1WStackedWidget.html#ffaa67bed3b16d9cca3c83a1d9386918">Wt::WStackedWidget</a>.</p>

</div>
</div><p>
<a class="anchor" name="1439877a32c4b082f312fee81d139665"></a><!-- doxytag: member="Wt::WContainerWidget::insertBefore" ref="1439877a32c4b082f312fee81d139665" args="(WWidget *widget, WWidget *before)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::insertBefore           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&nbsp;</td>
          <td class="paramname"> <em>widget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&nbsp;</td>
          <td class="paramname"> <em>before</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a child widget in this container, before another widget. 
<p>
The <em>widget</em> is inserted at the place of the <code>before</code> widget, and subsequent widgets are shifted.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#15ffcecaf10e6f04ec5667d2b3f0d919" title="Inserts a child widget in this container at given index.">insertWidget(int index, WWidget *widget)</a>; </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1Ext_1_1Splitter.html#d156963c4ad3d725e0d8b4bd2969b2f7">Wt::Ext::Splitter</a>.</p>

</div>
</div><p>
<a class="anchor" name="15ffcecaf10e6f04ec5667d2b3f0d919"></a><!-- doxytag: member="Wt::WContainerWidget::insertWidget" ref="15ffcecaf10e6f04ec5667d2b3f0d919" args="(int index, WWidget *widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::insertWidget           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&nbsp;</td>
          <td class="paramname"> <em>widget</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a child widget in this container at given index. 
<p>
The <em>widget</em> is inserted at the given <code>index</code>, and subsequent widgets are shifted.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#1439877a32c4b082f312fee81d139665" title="Inserts a child widget in this container, before another widget.">insertBefore(WWidget *widget, WWidget *before)</a>; </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1Ext_1_1Splitter.html#4495c1d701edd2181dbc1bf071442363">Wt::Ext::Splitter</a>, and <a class="el" href="classWt_1_1WStackedWidget.html#7a199e9cf57bee54333880534070767c">Wt::WStackedWidget</a>.</p>

</div>
</div><p>
<a class="anchor" name="4292867b1872bd31c7d0c3346d988470"></a><!-- doxytag: member="Wt::WContainerWidget::removeWidget" ref="4292867b1872bd31c7d0c3346d988470" args="(WWidget *widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::removeWidget           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&nbsp;</td>
          <td class="paramname"> <em>widget</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a child widget from this container. 
<p>
This removes the widget from this container, but does not delete the widget ! 
<p>Reimplemented in <a class="el" href="classWt_1_1WStackedWidget.html#c6df7a2910d43efead64405866043156">Wt::WStackedWidget</a>.</p>

</div>
</div><p>
<a class="anchor" name="608f748cbdda763f1a11556ddad9fbe1"></a><!-- doxytag: member="Wt::WContainerWidget::clear" ref="608f748cbdda763f1a11556ddad9fbe1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes and deletes all child widgets. 
<p>
This deletes all children that have been added to this container.<p>
If a layout was set, also the layout manager is deleted. 
</div>
</div><p>
<a class="anchor" name="ba13c9e62c74bcba53519ee9cf41f40a"></a><!-- doxytag: member="Wt::WContainerWidget::setContentAlignment" ref="ba13c9e62c74bcba53519ee9cf41f40a" args="(WFlags&lt; AlignmentFlag &gt; contentAlignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setContentAlignment           </td>
          <td>(</td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>contentAlignment</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies how child widgets must be aligned within the container. 
<p>
For a <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a>, only specifes the horizontal alignment of child widgets. Note that there is no way to specify vertical alignment: children are always pushed to the top of the container.<p>
For a <a class="el" href="classWt_1_1WTableCell.html" title="A container widget that represents a cell in a table.">WTableCell</a>, this may also specify the vertical alignment. The default alignment is (<a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f58fe5182bd266132c59718c6d30945a9">AlignTop </a> | <a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143fd033ef69b45d0b75633be34168c9b606">AlignLeft </a>). 
</div>
</div><p>
<a class="anchor" name="fa5f6800e2170ae2f4586a25c72f8c34"></a><!-- doxytag: member="Wt::WContainerWidget::setPadding" ref="fa5f6800e2170ae2f4586a25c72f8c34" args="(const WLength &amp;padding, WFlags&lt; Side &gt; sides=All)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setPadding           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#5a6f4636bcc6ab3c075165d249b3a5a3">Side</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>sides</em> = <code><a class="el" href="namespaceWt.html#3358b8309fdb63a402efcb1a577855e8">All</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets padding inside the widget. 
<p>
Setting padding has the effect of adding distance between the widget children and the border. 
</div>
</div><p>
<a class="anchor" name="326a0c9d7e4307dfd9c6979a2c441a96"></a><!-- doxytag: member="Wt::WContainerWidget::padding" ref="326a0c9d7e4307dfd9c6979a2c441a96" args="(Side side) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WLength.html">WLength</a> Wt::WContainerWidget::padding           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWt.html#5a6f4636bcc6ab3c075165d249b3a5a3">Side</a>&nbsp;</td>
          <td class="paramname"> <em>side</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the padding set for the widget. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#fa5f6800e2170ae2f4586a25c72f8c34" title="Sets padding inside the widget.">setPadding(const WLength&amp;, WFlags&lt;Side&gt;)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="042dbe790f34279f1978bc87610933df"></a><!-- doxytag: member="Wt::WContainerWidget::contentAlignment" ref="042dbe790f34279f1978bc87610933df" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WFlags&lt;<a class="el" href="namespaceWt.html#b8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a>&gt; Wt::WContainerWidget::contentAlignment           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the alignment of children. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#ba13c9e62c74bcba53519ee9cf41f40a" title="Specifies how child widgets must be aligned within the container.">setContentAlignment(WFlags&lt;AlignmentFlag&gt;)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e269f870992c5843d3097a63795b10d6"></a><!-- doxytag: member="Wt::WContainerWidget::setOverflow" ref="e269f870992c5843d3097a63795b10d6" args="(Overflow overflow, WFlags&lt; Orientation &gt; orientation=(Horizontal|Vertical))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setOverflow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WContainerWidget.html#bcc1911965f1669b94bd3f8fbf86a2d6">Overflow</a>&nbsp;</td>
          <td class="paramname"> <em>overflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#2a8d45559e16a0185bf61bfad0a67912">Orientation</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>orientation</em> = <code>(Horizontal&nbsp;|&nbsp;Vertical)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets how overflow of contained children must be handled. 
<p>
This is an alternative (CSS-ish) way to provide scroll bars on a container widget, compared to wrapping inside a <a class="el" href="classWt_1_1WScrollArea.html" title="A widget that adds scrolling capabilities to its content.">WScrollArea</a>.<p>
Note that currently, you cannot separately specify vertical and horizontal scroll behaviour, since this is not supported on Opera. Therefore, settings will apply automatically to both orientations.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For Internet Explorer, setting overflow to OverflowAuto or OverflowScroll may cause problems with content that uses absolutely positioned DOM elements (such as <a class="el" href="classWt_1_1WPaintedWidget.html" title="A widget that is painted using vector graphics.">WPaintedWidget</a> or several Ext widgets): due to a bug in IE, these elements will not scroll along, but stay 'fixed' at their initial position. This problem can (usually) be circumvented by using a relative position scheme relative (using <a class="el" href="classWt_1_1WWebWidget.html#d4258f03ed3dcadc71b4f2217f4fc76a">setPositionScheme(Relative)</a>) for the same container widget which provides the scroll bars.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WScrollArea.html" title="A widget that adds scrolling capabilities to its content.">WScrollArea</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b1857ba8e8a677887cd20aa657fb77f"></a><!-- doxytag: member="Wt::WContainerWidget::setList" ref="4b1857ba8e8a677887cd20aa657fb77f" args="(bool list, bool ordered=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setList           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ordered</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Renders the container as an HTML list. 
<p>
Setting <code>renderList</code> to <code>true</code> will cause the container to be using an HTML <code>&lt;ul&gt;</code> or <code>&lt;ol&gt;</code> type, depending on the value of <code>orderedList</code>. This must be set before the initial render of the container. When set, any contained <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a> will be rendered as an HTML <code>&lt;li&gt;</code>. Adding non-WContainerWidget children results in unspecified behaviour.<p>
Note that CSS default layout rules for <code>&lt;ul&gt;</code> and <code>&lt;ol&gt;</code> add margin and padding to the container, which may look odd if you do not use bullets.<p>
By default, a container is rendered using a <code>&lt;div&gt;</code> element.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#f7c9ba23a66d27cb7442557284464f3f" title="Returns if this container is rendered as an Ordered List.">isOrderedList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#e0db17987ae260b71d860b8f670c0c8a" title="Returns if this container is rendered as an Unordered List.">isUnorderedList()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ba1ccbc634a57f21608c410d28bbff5"></a><!-- doxytag: member="Wt::WContainerWidget::isList" ref="2ba1ccbc634a57f21608c410d28bbff5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::WContainerWidget::isList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if this container is rendered as a List. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#f7c9ba23a66d27cb7442557284464f3f" title="Returns if this container is rendered as an Ordered List.">isOrderedList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#e0db17987ae260b71d860b8f670c0c8a" title="Returns if this container is rendered as an Unordered List.">isUnorderedList()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e0db17987ae260b71d860b8f670c0c8a"></a><!-- doxytag: member="Wt::WContainerWidget::isUnorderedList" ref="e0db17987ae260b71d860b8f670c0c8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::WContainerWidget::isUnorderedList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if this container is rendered as an Unordered List. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#f7c9ba23a66d27cb7442557284464f3f" title="Returns if this container is rendered as an Ordered List.">isOrderedList()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f7c9ba23a66d27cb7442557284464f3f"></a><!-- doxytag: member="Wt::WContainerWidget::isOrderedList" ref="f7c9ba23a66d27cb7442557284464f3f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::WContainerWidget::isOrderedList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if this container is rendered as an Ordered List. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#e0db17987ae260b71d860b8f670c0c8a" title="Returns if this container is rendered as an Unordered List.">isUnorderedList()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="64b97ae076fc6d678305fcdf77738a31"></a><!-- doxytag: member="Wt::WContainerWidget::scrolled" ref="64b97ae076fc6d678305fcdf77738a31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1EventSignal.html">EventSignal</a>&lt; <a class="el" href="classWt_1_1WScrollEvent.html">WScrollEvent</a> &gt; &amp; Wt::WContainerWidget::scrolled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event signal emitted when scrolling in the widget. 
<p>
This event is emitted when the user scrolls in the widget (for setting the scroll bar policy, see <a class="el" href="classWt_1_1WContainerWidget.html#e269f870992c5843d3097a63795b10d6" title="Sets how overflow of contained children must be handled.">setOverflow()</a>). The event conveys details such as the new scroll bar position, the total contents height and the current widget height.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#e269f870992c5843d3097a63795b10d6" title="Sets how overflow of contained children must be handled.">setOverflow()</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Fri Sep 10 16:33:02 2010 for <a href="http://www.webtoolkit.eu/wt/">Wt</a> by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
