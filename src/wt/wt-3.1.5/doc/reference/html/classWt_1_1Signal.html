<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Wt: Wt::Signal&lt; A1, A2, A3, A4, A5, A6 &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceWt.html">Wt</a>::<a class="el" href="classWt_1_1Signal.html">Signal</a>
  </div>
</div>
<div class="contents">
<h1>Wt::Signal&lt; A1, A2, A3, A4, A5, A6 &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__signalslot.html">Signal/slot system</a>]</small>
</h1><!-- doxytag: class="Wt::Signal" --><!-- doxytag: inherits="Wt::SignalBase" -->A signal that propagates events to listeners.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Wt/WSignal&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Wt::Signal&lt; A1, A2, A3, A4, A5, A6 &gt;:</div>
<div class="dynsection">
<p><center><img src="classWt_1_1Signal__inherit__graph.png" border="0" usemap="#Wt_1_1Signal_3_01A1_00_01A2_00_01A3_00_01A4_00_01A5_00_01A6_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="Wt_1_1Signal_3_01A1_00_01A2_00_01A3_00_01A4_00_01A5_00_01A6_01_4__inherit__map">
<area shape="rect" href="classWt_1_1SignalBase.html" title="Abstract base class of a signal." alt="" coords="69,5,181,35"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classWt_1_1Signal-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#a481062b581f9d2f071bf07b421d87ca">Signal</a> (<a class="el" href="classWt_1_1WObject.html">WObject</a> *sender=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a signal.  <a href="#a481062b581f9d2f071bf07b421d87ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e665a336ae3e576bcb372f16c306d4d1"></a><!-- doxytag: member="Wt::Signal::~Signal" ref="e665a336ae3e576bcb372f16c306d4d1" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#e665a336ae3e576bcb372f16c306d4d1">~Signal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual boost::signals::connection&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3">connect</a> (<a class="el" href="classWt_1_1WObject.html">WObject</a> *target, <a class="el" href="classWt_1_1WObject.html#6ef714d6ef0060b78c039e729b913aa9">WObject::Method</a> method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects to a slot.  <a href="#15d1150af031537b492674ee651bf4a3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#04c1f708f726035cac24a8f5726e4b74">connect</a> (const F &amp;function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects to a function.  <a href="#04c1f708f726035cac24a8f5726e4b74"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#e6b9bffa47c0ffdd1667e8f13e8dab74">connect</a> (T *target, void(V::*method)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects a slot that takes no arguments.  <a href="#e6b9bffa47c0ffdd1667e8f13e8dab74"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#7f296d5965c03785c7a635431f7f6a79">connect</a> (T *target, void(V::*method)(A1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects a slot that takes one argument.  <a href="#7f296d5965c03785c7a635431f7f6a79"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#a1a8436d769d11f5cb0c1febafd1e27d">connect</a> (T *target, void(V::*method)(A1, A2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects a slot that takes two arguments.  <a href="#a1a8436d769d11f5cb0c1febafd1e27d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#239b63678084087ba15fd17f6ab1a312">connect</a> (T *target, void(V::*method)(A1, A2, A3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects a slot that takes three arguments.  <a href="#239b63678084087ba15fd17f6ab1a312"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#976facef99c1a6a53871bd7118c7e1bc">connect</a> (T *target, void(V::*method)(A1, A2, A3, A4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects a slot that takes four arguments.  <a href="#976facef99c1a6a53871bd7118c7e1bc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#906499f6b97c28d1da8b5c615aee41dc">connect</a> (T *target, void(V::*method)(A1, A2, A3, A4, A5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects a slot that takes five arguments.  <a href="#906499f6b97c28d1da8b5c615aee41dc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">boost::signals::connection&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#d5eaf26f300335ccbf37ed71026ff1b7">connect</a> (T *target, void(V::*method)(A1, A2, A3, A4, A5, A6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects a slot that takes six arguments.  <a href="#d5eaf26f300335ccbf37ed71026ff1b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#8d9cf8a1e83634462fe2b492b3beb1c5">emit</a> (A1 a1=NoClass::none, A2 a2=NoClass::none, A3 a3=NoClass::none, A4 a4=NoClass::none, A5 a5=NoClass::none, A6 a6=NoClass::none) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits the signal.  <a href="#8d9cf8a1e83634462fe2b492b3beb1c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#10c70ce5cafb6170e56e8df36bbb9a7a">operator()</a> (A1 a1=NoClass::none, A2 a2=NoClass::none, A3 a3=NoClass::none, A4 a4=NoClass::none, A5 a5=NoClass::none, A6 a6=NoClass::none) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits the signal.  <a href="#10c70ce5cafb6170e56e8df36bbb9a7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Signal.html#4a65919846e7d1cedabd0e9acc65563a">isConnected</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether this signal is connected.  <a href="#4a65919846e7d1cedabd0e9acc65563a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename A1 = NoClass, typename A2 = NoClass, typename A3 = NoClass, typename A4 = NoClass, typename A5 = NoClass, typename A6 = NoClass&gt;<br>
 class Wt::Signal&lt; A1, A2, A3, A4, A5, A6 &gt;</h3>

A signal that propagates events to listeners. 
<p>
Use Signal/slots to let one object (<em>A</em>) listen to events caused by another object (<em>B</em>). In this scenario, object <em>B</em> provides in its public interface access to a signal, to which object <em>A</em> connects one of its member function (which act as slot). Object <em>A</em> can then signal an event (which triggers the connected callback functions), by emitting the signal. Signal/slot is a generalization of the popular observer pattern used in GUIs.<p>
A signal can provide details of the event, using up to 6 parameters. A slot must have a compatible signature to connect to a signal, based on its parameters. A compatible signature provides the same parameters in the member function, or less (leaving out parameters at the end).<p>
The signal automatically disconnects from the slot when the target is deleted. In addition, the signal may be deleted at any time, in particular also while it is being emitted.<p>
The Signal objects integrate with <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a> objects. A Signal requires that the target of a connection, i.e. the object that listens for an event, is a WObject. In addition, every signal may specify one WObject to be the owner of the signal, and a target may find out the sender of a signal emission, using <a class="el" href="classWt_1_1WObject.html#413deb54de40ee278dd554e4960d58ca" title="Returns the sender of the current slot call.">WObject::sender()</a>.<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyWidget : <span class="keyword">public</span> Wt::WContainerWidget
 {
 <span class="keyword">public</span>:
   MyWidget(<a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *parent = 0)
     : Wt::WContainerWidget(parent),
       done_(this)
   {
      ...
      <a class="code" href="classWt_1_1WPushButton.html" title="A widget that represents a push button.">Wt::WPushButton</a> *button = <span class="keyword">new</span> <a class="code" href="classWt_1_1WPushButton.html" title="A widget that represents a push button.">Wt::WPushButton</a>(<span class="stringliteral">"Okay"</span>);
      button-&gt;<a class="code" href="classWt_1_1WInteractWidget.html#e11e050cce0d4a8f742afa3ef92bfe8c" title="Event signal emitted when a mouse key was clicked on this widget.">clicked</a>().connect(<span class="keyword">this</span>, &amp;MyWidget::process);
   }

   <span class="comment">// provide an accessor for the signal</span>
   <a class="code" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Wt::Signal&lt;int, std::string&gt;</a>&amp; done() { <span class="keywordflow">return</span> done_; }

 <span class="keyword">private</span>:
   <a class="code" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Wt::Signal&lt;int, std::string&gt;</a> done_;

   <span class="keywordtype">void</span> process() {
     ...
     done_.emit(42, <span class="stringliteral">"Totally done"</span>); <span class="comment">// emit the signal</span>
   }
 };
</pre></div><p>
This widget could then be used from another class: <div class="fragment"><pre class="fragment"> <span class="keyword">class </span>GUIClass : <span class="keyword">public</span> Wt::WContainerWidget
 {
   ...

 <span class="keyword">private</span>:
   <span class="keywordtype">void</span> init() {
     MyWidget *widget = <span class="keyword">new</span> MyWidget(<span class="keyword">this</span>);
     widget-&gt;done().connect(<span class="keyword">this</span>, &amp;GUIClass::whenDone);
   }

   <span class="keywordtype">void</span> whenDone(<span class="keywordtype">int</span> result, <span class="keyword">const</span> std::string&amp; description) {
     ...
   }
 };
</pre></div><p>
The <a class="el" href="classWt_1_1WSignalMapper.html" title="A utility class to connect multiple senders to a single slot.">WSignalMapper</a> is a utility class that helps in situations where you want to connect multiple signals to a single slot, and still be identify the sender using some property.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WSignalMapper.html" title="A utility class to connect multiple senders to a single slot.">WSignalMapper</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a481062b581f9d2f071bf07b421d87ca"></a><!-- doxytag: member="Wt::Signal::Signal" ref="a481062b581f9d2f071bf07b421d87ca" args="(WObject *sender=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::<a class="el" href="classWt_1_1Signal.html">Signal</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WObject.html">WObject</a> *&nbsp;</td>
          <td class="paramname"> <em>sender</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a signal. 
<p>
The <code>sender</code> is the object that will be identified as <a class="el" href="classWt_1_1WObject.html#413deb54de40ee278dd554e4960d58ca" title="Returns the sender of the current slot call.">WObject::sender()</a> when executing connected slots may be passed as an argument.<p>
The <code>sender</code> should not be <code>0</code> when you want to map the signal using the <a class="el" href="classWt_1_1WSignalMapper.html" title="A utility class to connect multiple senders to a single slot.">WSignalMapper</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="15d1150af031537b492674ee651bf4a3"></a><!-- doxytag: member="Wt::Signal::connect" ref="15d1150af031537b492674ee651bf4a3" args="(WObject *target, WObject::Method method)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WObject.html">WObject</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1WObject.html#6ef714d6ef0060b78c039e729b913aa9">WObject::Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects to a slot. 
<p>
Every signal can be connected to a slot which does not take any arguments (and may thus ignore signal arguments). 
<p>Implements <a class="el" href="classWt_1_1SignalBase.html#5161bdd49ba2dee3ddfa085c51e68bdb">Wt::SignalBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="04c1f708f726035cac24a8f5726e4b74"></a><!-- doxytag: member="Wt::Signal::connect" ref="04c1f708f726035cac24a8f5726e4b74" args="(const F &amp;function)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects to a function. 
<p>
This variant of the overloaded <a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3" title="Connects to a slot.">connect()</a> method supports a template function object (which supports operator ()).<p>
When the receiver function is an object method, the signal will automatically be disconnected when the object is deleted, as long as the object inherits from <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a> or boost::signals::trackable.<p>
The function may leave up to <em>N</em> parameters unbound (e.g. using boost::bind placeholders _1 to _N) that may be bound to values passed by the signal. 
</div>
</div><p>
<a class="anchor" name="e6b9bffa47c0ffdd1667e8f13e8dab74"></a><!-- doxytag: member="Wt::Signal::connect" ref="e6b9bffa47c0ffdd1667e8f13e8dab74" args="(T *target, void(V::*method)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class T, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(V::*)()&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects a slot that takes no arguments. 
<p>
This is always possible (even when the signal specifies a number of arguments).<p>
The slot is as a <code>method</code> of an object <code>target</code> of class <code>T</code>, which equals class <code>V</code>, or is a base class of class <code>V</code>. Thus, the following statement must return a non-null pointer:<p>
<div class="fragment"><pre class="fragment"> V *v = <span class="keyword">dynamic_cast&lt;</span>V *<span class="keyword">&gt;</span>(target);
</pre></div><p>
In practice, to facilitate automatic disconnects on deletion of the <code>target</code>, class <code>T</code> must be also be a descendant of <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, but this is not enforced by the interface. 
<p>Reimplemented from <a class="el" href="classWt_1_1SignalBase.html#462d1a3c0a7db6a5ad03cee69e6e8c28">Wt::SignalBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="7f296d5965c03785c7a635431f7f6a79"></a><!-- doxytag: member="Wt::Signal::connect" ref="7f296d5965c03785c7a635431f7f6a79" args="(T *target, void(V::*method)(A1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class T, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(V::*)(A1)&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects a slot that takes one argument. 
<p>
This is only possible for signals that take at least one argument.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3" title="Connects to a slot.">connect</a>(T *target, void (V::*method)()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="a1a8436d769d11f5cb0c1febafd1e27d"></a><!-- doxytag: member="Wt::Signal::connect" ref="a1a8436d769d11f5cb0c1febafd1e27d" args="(T *target, void(V::*method)(A1, A2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class T, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(V::*)(A1, A2)&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects a slot that takes two arguments. 
<p>
This is only possible for signals that take at least two arguments.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3" title="Connects to a slot.">connect</a>(T *target, void (V::*method)()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="239b63678084087ba15fd17f6ab1a312"></a><!-- doxytag: member="Wt::Signal::connect" ref="239b63678084087ba15fd17f6ab1a312" args="(T *target, void(V::*method)(A1, A2, A3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class T, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(V::*)(A1, A2, A3)&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects a slot that takes three arguments. 
<p>
This is only possible for signals that take at least three arguments.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3" title="Connects to a slot.">connect</a>(T *target, void (V::*method)()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="976facef99c1a6a53871bd7118c7e1bc"></a><!-- doxytag: member="Wt::Signal::connect" ref="976facef99c1a6a53871bd7118c7e1bc" args="(T *target, void(V::*method)(A1, A2, A3, A4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class T, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(V::*)(A1, A2, A3, A4)&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects a slot that takes four arguments. 
<p>
This is only possible for signals that take at least four arguments.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3" title="Connects to a slot.">connect</a>(T *target, void (V::*method)()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="906499f6b97c28d1da8b5c615aee41dc"></a><!-- doxytag: member="Wt::Signal::connect" ref="906499f6b97c28d1da8b5c615aee41dc" args="(T *target, void(V::*method)(A1, A2, A3, A4, A5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class T, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(V::*)(A1, A2, A3, A4, A5)&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects a slot that takes five arguments. 
<p>
This is only possible for signals that take at least five arguments.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3" title="Connects to a slot.">connect</a>(T *target, void (V::*method)()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="d5eaf26f300335ccbf37ed71026ff1b7"></a><!-- doxytag: member="Wt::Signal::connect" ref="d5eaf26f300335ccbf37ed71026ff1b7" args="(T *target, void(V::*method)(A1, A2, A3, A4, A5, A6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
<div class="memtemplate">
template&lt;class T, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals::connection <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(V::*)(A1, A2, A3, A4, A5, A6)&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects a slot that takes six arguments. 
<p>
This is only possible for signals that take at least six arguments.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1Signal.html#15d1150af031537b492674ee651bf4a3" title="Connects to a slot.">connect</a>(T *target, void (V::*method)()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d9cf8a1e83634462fe2b492b3beb1c5"></a><!-- doxytag: member="Wt::Signal::emit" ref="8d9cf8a1e83634462fe2b492b3beb1c5" args="(A1 a1=NoClass::none, A2 a2=NoClass::none, A3 a3=NoClass::none, A4 a4=NoClass::none, A5 a5=NoClass::none, A6 a6=NoClass::none) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::emit           </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em> = <code>NoClass::none</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits the signal. 
<p>
The arguments must exactly match the arguments of the target function.<p>
This will cause all connected slots to be triggered, with the given arguments. 
</div>
</div><p>
<a class="anchor" name="10c70ce5cafb6170e56e8df36bbb9a7a"></a><!-- doxytag: member="Wt::Signal::operator()" ref="10c70ce5cafb6170e56e8df36bbb9a7a" args="(A1 a1=NoClass::none, A2 a2=NoClass::none, A3 a3=NoClass::none, A4 a4=NoClass::none, A5 a5=NoClass::none, A6 a6=NoClass::none) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em> = <code>NoClass::none</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em> = <code>NoClass::none</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emits the signal. 
<p>
This is equivalent to <a class="el" href="classWt_1_1Signal.html#8d9cf8a1e83634462fe2b492b3beb1c5" title="Emits the signal.">emit()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1Signal.html#8d9cf8a1e83634462fe2b492b3beb1c5" title="Emits the signal.">emit</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a65919846e7d1cedabd0e9acc65563a"></a><!-- doxytag: member="Wt::Signal::isConnected" ref="4a65919846e7d1cedabd0e9acc65563a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt; A1, A2, A3, A4, A5, A6 &gt;::isConnected           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether this signal is connected. 
<p>
Returns true when the signal was connected to to at least one slot. 
<p>Implements <a class="el" href="classWt_1_1SignalBase.html#13a3106be8949b273edc74aa61be14ce">Wt::SignalBase</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Fri Sep 10 16:33:03 2010 for <a href="http://www.webtoolkit.eu/wt/">Wt</a> by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
